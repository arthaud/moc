// assembleur inline en dehors d'une fonction
asm {
    CALL (LB) _main   ; appel au point d'entrée du programme
    HALT              ; arrêt de la machine
}

// assembleur inline dans une fonction
int * malloc(int taille) {
    asm {
        LOAD %taille    ; accès au parametre taille
        SUBR Malloc     ; allocation
        RETURN (1) 1
    }
}

// assembleur inline dans une fonction
void log(char *message, int valeur) {
    int x = 12;
    asm {
        LOAD %message        ; accès au premier paramètre
        SUBR Sout            ; afficher message
        LOAD %valeur         ; accès au deuxieme paramètre
        LOADL 1
        SUBR IAdd
        STORE %x             ; écrire valeur + 1 dans x
        LOAD %x              ; accès à la variable x
        SUBR IOUT            ; afficher x
        SUBR LN
        RETURN (2) 0
    }
}

// fonction illustrant la manipulation de pointeurs
int foo(int n) {
    // déclaration sans initialisation
    int xxx;
    xxx = 100;

    // déclaration avec initialisation
    int a = n + 999;

    // déclaration d'un pointeur
    int *m = malloc(1);
    a = *m + 666;

    // déclaration d'un pointeur sur pointeur
    int ** k = malloc(2) ;
    *k = m;
    ** k = 12;
    int b = **k + 9999;

    // cast
    m = (int *)malloc(10);
    return m;
}

// fonction renvoyant un pointeur
int * ref(int x) {
    int *p = malloc(x);
    return p;
}

// fonction illustrant les expressions arithméthiques
int bar(int a, int b) {
    int u = 301;
    int v = 401;
    int result;
    result = foo(33*a - b > (-55*u/22%11/v));

    return result;
}

// point d'entrée du programme
int main() {
    log("Hello, world ! ", bar(98,99));
    char c = 'a';
    int y = 999;

    // instruction conditionnelle
    if (y ==0){
        log("alors", y);
    }
    else {
        log("sinon", y);
    }

    return y;
}
