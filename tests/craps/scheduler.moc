asm("
    ba start
    // interrupt table
    .word pwm_handler
    .word pwm_handler
    .word null_handler
    .word null_handler
    null_handler: reti
    start:
    set 0x180, %sp
    ba f_init
")

int pwm_count;
int process_table;
int malloc_start;

asm("
    pwm_handler:

    push %r1

    ld $pwm_count, %r1
    inccc %r1

    cmp %r1, 100
    bl pwm_handler_end

    xor %r1, %r1, %r1 // set to 0

    // context switch
    /////////////////
    
    push %r2
    push %r3
    push %r4
    push %r5
    push %r6
    push %r7
    push %r8
    push %r9
    ld $process_table, %r2
    ld [%r2], %r3 // %r3: nb_tasks
    ld [%r2+1], %r4 // %r4: current_task
    umulcc %r4, 14, %r5
    add %r5, 2, %r5
    add %r5, %r2, %r5 // %r5: current task entry
    
    // %r9
    pop %r6
    st %r6, [%r5+8]
    // %r8
    pop %r6
    st %r6, [%r5+7]
    // %r7
    pop %r6
    st %r6, [%r5+6]
    // %r6
    pop %r6
    st %r6, [%r5+5]
    // %r5
    pop %r6
    st %r6, [%r5+4]
    // %r4
    pop %r6
    st %r6, [%r5+3]
    // %r3
    pop %r6
    st %r6, [%r5+2]
    // %r2
    pop %r6
    st %r6, [%r5+1]
    // %r1
    pop %r6
    st %r6, [%r5]

    // before %r1 we have psr and then pc to also set
    
    // pc
    pop %r6
    st %r6, [%r5+13]

    // psr
    pop %r6
    st %r6, [%r5+9]

    st %sp, [%r5+12]
    st %fp, [%r5+10]
    st %r28, [%r5+11]
    
    // now it is stored, we can load the other task

    // current_task = (current_task + 1) mod nb_tasks
    inccc %r4
    cmp %r4, %r3
    bl pwm_handler_afterreset
    xor %r4, %r4, %r4 // %r4 <- 0
    pwm_handler_afterreset:

    umulcc %r4, 14, %r5
    add %r5, 2, %r5
    add %r5, %r2, %r5 // %r5: current task entry

    // don't forget to store the incremented counter
    st %r1, $pwm_count

    // load the registers

    // We switch the stack now that everything is pop'ed
    ld [%r5+12], %sp
    ld [%r5+10], %fp
    ld [%r5+11], %r28

    // psr
    ld [%r5+9], %r6
    push %r6
    // pc
    ld [%r5+13], %r6
    push %r6
    
    // load all the registers !
    ld [%r5+8], %r9
    ld [%r5+7], %r8
    ld [%r5+6], %r7
    ld [%r5+5], %r6
    ld [%r5+4], %r5
    ld [%r5+3], %r4
    ld [%r5+2], %r3
    ld [%r5+1], %r2
    ld [%r5], %r1
    
    reti

    /////////////////////
    // end context switch

    pwm_handler_end:
    st %r1, $pwm_count
    pop %r1
    reti
")

int syscall_malloc(int size)
{
    // implémentation du célèbre « Maxime Arthaud's malloc »
    int old_malloc_start = malloc_start;
    malloc_start = malloc_start + size;
    return old_malloc_start;
}

// int nb_tasks;
// int current_task;
// {
//   int r1; // 0
//   int r2; // 1
//   int r3; // 2
//   int r4; // 3
//   int r5; // 4
//   int r6; // 5
//   int r7; // 6
//   int r8; // 7
//   int r9; // 8
//   int fpr; // %r25
//   int fp; // 10
//   int ret; // 11
//   int sp;
//   int pc;
// }

int task1()
{
    int* ssegs = (int*) 0xA0000000;
    while(true)
    {
        *(ssegs + 1) = 0b1111;
        *ssegs = 0x4321;
    }
}

int task2()
{
    int* ssegs = (int*) 0xA0000000;
    while(true)
    {
        *(ssegs + 1) = 0b1111;
        *ssegs = 0x1234;
    }
}

int init() {
    pwm_count = 0;
    malloc_start = 0x185;

    // alloc the process table
    process_table = syscall_malloc(2 + 14*2);

    // zfill the registers
    int i = 0;
    while(i < 14*2)
    {
        *((int*)process_table + 2 + i) = 0;
        i = i + 1;
    }

    // nb_tasks and current_task
    *((int*)process_table) = 2;
    *((int*)process_table+1) = 0;

    // pc
    int task;
    asm("set f_task1, %r9
    st %r9, $task");
    *((int*)process_table+2+13) = task;
    asm("set f_task2, %r9
    st %r9, $task");
    *((int*)process_table+2+14+13) = task;

    // sp
    *((int*)process_table+2+12) = syscall_malloc(256);
    *((int*)process_table+2+14+12) = syscall_malloc(256);

    // un front montant du PWM toutes les millisecondes
    *((int*)0xC0000000) = 195; // P
    *((int*)0xC0000001) = 98; // N

    asm("
    // load %sp
    ld $process_table, %r2
    ld [%r2], %r3 // %r3: nb_tasks
    ld [%r2+1], %r4 // %r4: current_task
    umulcc %r4, 14, %r5
    add %r5, 2, %r5
    add %r5, %r2, %r5 // %r5: current task entry
    ld [%r5+12], %sp

    // jump to the task
    //ld [%r5+13], %r6
    //mov %r6, %pc
    ba f_task1
    ");
}

