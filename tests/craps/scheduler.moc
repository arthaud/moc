asm("
    ba start
    // interrupt table
    .word pwm_handler
    .word pwm_handler
    .word null_handler
    .word null_handler
    null_handler: reti
    start:
    set 0x180, %sp
    ba f_main
")

int pwm_count;
int process_table;
int malloc_start;

asm("
    pwm_handler:

    push %r1

    ld $pwm_count, %r1
    inccc %r1

    cmp %r1, 100
    bl pwm_handler_end

    xor %r1, %r1, %r1 // set to 0

    // context switch
    /////////////////
    
    push %r2
    push %r3
    push %r4
    push %r5
    push %r6
    push %r7
    push %r8
    push %r9

    ld $process_table, %r2
    ld [%r2], %r3 // %r3: nb_tasks
    ld [%r2+1], %r4 // %r4: current_task
    add %r4, 2, %r5
    add %r5, %r2, %r5 // %r5: current task entry
    
    st %sp, [%r5]

    push %fp
    push %r28
    
    // now it is stored, we can load the other task

    // current_task = (current_task + 1) mod nb_tasks
    inccc %r4
    cmp %r4, %r3
    bl pwm_handler_afterreset
    xor %r4, %r4, %r4 // %r4 <- 0
    pwm_handler_afterreset:

    st %r4, [%r2+1]
    // don't forget to store the incremented counter
    st %r1, $pwm_count

    add %r4, 2, %r5
    add %r5, %r2, %r5 // %r5: current task entry

    // We switch the stack now that everything is pop'ed
    ld [%r5], %sp

    pop %r28
    pop %fp
    pop %r9
    pop %r8
    pop %r7
    pop %r6
    pop %r5
    pop %r4
    pop %r3
    pop %r2
    pop %r1
    
    reti

    /////////////////////
    // end context switch

    pwm_handler_end:
    st %r1, $pwm_count
    pop %r1
    reti
")

int syscall_malloc(int size)
{
    // implémentation du célèbre « Maxime Arthaud's malloc »
    int old_malloc_start = malloc_start;
    malloc_start = malloc_start + size;
    return old_malloc_start;
}

// int nb_tasks;
// int current_task;
// {
//   int r1; // 0
//   int r2; // 1
//   int r3; // 2
//   int r4; // 3
//   int r5; // 4
//   int r6; // 5
//   int r7; // 6
//   int r8; // 7
//   int r9; // 8
//   int psr; // %r25
//   int fp; // 10
//   int ret; // 11
//   int sp;
//   int pc;
// }

export int task1()
{
    int* ssegs = (int*) 0xA0000000;
    while(true)
    {
        *(ssegs + 1) = 0b1111;
        *ssegs = 0x4321;
    }
}

export int task2()
{
    int* ssegs = (int*) 0xA0000000;
    while(true)
    {
        *(ssegs + 1) = 0b1111;
        *ssegs = 0x1234;
    }
}

int main() {
    pwm_count = 0;
    malloc_start = 0x185;

    // alloc the process table
    process_table = syscall_malloc(2 + 14*2);

    // zfill the registers
    int i = 0;
    while(i < 14*2)
    {
        *((int*)process_table + 2 + i) = 0;
        i = i + 1;
    }

    // nb_tasks and current_task
    *((int*)process_table) = 2;
    *((int*)process_table+1) = 0;

    // pc
    int task;
    asm("set f_task1, %r9
    st %r9, $task");
    *((int*)process_table+2+13) = task;
    asm("set f_task2, %r9
    st %r9, $task");
    *((int*)process_table+2+14+13) = task;

    // sp
    *((int*)process_table+2+12) = syscall_malloc(256) + 255;
    *((int*)process_table+2+14+12) = syscall_malloc(256) + 255;

    // un front montant du PWM toutes les millisecondes
    *((int*)0xC0000000) = 195; // P
    *((int*)0xC0000001) = 98; // N

    asm("
    // load %sp
    ld $process_table, %r2
    ld [%r2], %r3 // %r3: nb_tasks
    ld [%r2+1], %r4 // %r4: current_task
    add %r2, 2, %r5
    add %r5, %r4, %r5 // %r5: current task entry
    ld [%r5], %sp

    // jump to the task
    //ld [%r5+13], %r6
    //mov %r6, %pc
    ba f_task1
    ");
}

