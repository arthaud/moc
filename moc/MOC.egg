-------------------------
-- MC and MOC grammars --
-------------------------

option auto = true;
option version = 0.0.1;
option k = 2;

inh source : MOCSourceFile for
         PROGRAM, ENTITIES, FUNCTION, INST, BLOC, INSTS, ELSE,
         FUNC_PARAMETERS, FUNC_PARAMETER, FUNC_PARAMETERSX, ARGS, ARGSX,
         E, EX, A, AX, R, RX, T, TX, F
--       -- TODO: MOC
--       ,IMPLEMENTATION, METHODS, METHOD, ATTRIBUTES, MFUNC_PARAMETER, MFUNC_PARAMETERS, MARG, MARGS
         ;
inh machine : IMachine for
         ENTITIES, FUNCTION, INST, BLOC, INSTS, ELSE,
         FUNC_PARAMETERS, FUNC_PARAMETER, FUNC_PARAMETERSX, ARGS, ARGSX,
         TYPE, STYPE, REFS,
         E, EX, A, AX, R, RX, T, TX, F
--       -- TODO: MOC
--       ,IMPLEMENTATION, METHODS, METHOD, ATTRIBUTES, MFUNC_PARAMETER, MFUNC_PARAMETERS, MARG, MARGS
         ;
inh st : ST for
         ENTITIES, FUNCTION, INST, BLOC, INSTS, ELSE,
         FUNC_PARAMETERS, FUNC_PARAMETER, FUNC_PARAMETERSX, ARGS, ARGSX,
         E, EX, A, AX, R, RX, T, TX, F
--       -- TODO: MOC
--       ,IMPLEMENTATION, METHODS, METHOD, ATTRIBUTES, MFUNC_PARAMETER, MFUNC_PARAMETERS, MARG, MARGS
         ;
inh types : LTYPES for FUNC_PARAMETERS, FUNC_PARAMETERSX, ARGS, ARGSX;
syn type : TTYPE for
         TYPE, FUNC_PARAMETER, STYPE, REFS,
         E, EX, A, AX, R, RX, T, TX, F;
inh htype : TTYPE for REFS, EX, AX, RX, TX;
syn name : STRING for OPREL, OPADD, OPMUL, OPUN, FUNC_PARAMETER;
inh locator : ParametersLocator for FUNC_PARAMETERS, FUNC_PARAMETERSX;

-- to check subprogram call
inh function : TFUNCTION for ARGS, ARGSX;

-- these attributes allow to get inline assembly
syn asm_code : STRING for ASM;
inh asm_st : ST for ASM;

space separator  is  "[\r\n\t ]+" ;
space comm       is  "\/\/[^\n]*\n" ;
sugar opar       is  "\(" ;
sugar cpar       is  "\)" ;
sugar ocbra      is  "\{" ;
sugar ccbra      is  "\}" ;
sugar comma      is  "," ;
sugar semicolon  is  "\;" ;
sugar affect     is  "=" ;
sugar if         is  "if" ;
sugar else       is  "else" ;
sugar void       is  "void" ;
sugar asm        is  "asm" ;
sugar int        is  "int" ;
sugar char       is  "char" ;
sugar bool       is  "bool" ;
sugar true       is  "true" ;
sugar false      is  "false" ;
sugar return     is  "return" ;
sugar null       is  "NULL" ;
sugar nil        is  "nil" ;
sugar inf        is  "\<" ;
sugar infeq      is  "\<=" ;
sugar sup        is  "\>" ;
sugar supeq      is  "\>=" ;
sugar eq         is  "==" ;
sugar neq        is  "\!=" ;
sugar plus       is  "\+" ;
sugar minus      is  "\-" ;
sugar or         is  "\|\|" ;
sugar and        is  "\&\&" ;
sugar mult       is  "\*" ;
sugar div        is  "\/" ;
sugar mod        is  "\%" ;
sugar not        is  "\!" ;

---- TODO: MOC
--sugar colon      is  "\:" ;
--sugar osbra      is  "\[" ;
--sugar csbra      is  "\]" ;
--sugar id         is  "id" ;
--sugar class      is  "@class" ;
--sugar end        is  "@end" ;
--sugar self       is "self" ;
--sugar bool       is  "BOOL" ;
--sugar super      is "super" ;
--sugar yes        is "YES" ;
--sugar no         is "NO" ;

term integer     is  "[0-9]+" ;
term character   is  "\'[^\']\'" ;
term string      is  "\"[^\"]*\"" ;
term ident       is  "[a-z][_0-9A-Za-z]*" ;
---- TODO: MOC
--term class_ident is  "[A-Z][_0-9A-Za-z]*" ; -- class name
--term stringo     is  "@\"[^\"]*\"" ; -- MOC string

-- for inline assembly
compil ASM;


PROGRAM -> #init ENTITIES #gen ;
global
    IMachine machine;
    ST st;

#init {
    machine = PROGRAM^source.getMachine();

    if (machine == null) {
        error(NO_MACH, PROGRAM^source.getMachName());
    }
    else {
        ENTITIES^machine = machine;
    }

    st = new ST();
    ENTITIES^st = st;
}

#gen {
    -- debug
    if (PROGRAM^source.getVerbosity() >= 1) {
        write("### final symbols table ###\n");
        write(st);
        write("###########################\n");
    }

    -- write in a file
    machine.writeCode(PROGRAM^source.getFileName(), "; no code\n");
}

ENTITIES -> ;
ENTITIES -> asm #st ASM ENTITIES #gen ;
#st {
    ASM^asm_st = ENTITIES^st;
}

#gen {
    -- ASM^asm_code contains the inline assembly
}

ENTITIES -> FUNCTION ENTITIES ;

-- functions
FUNCTION -> TYPE ident opar #trans FUNC_PARAMETERS cpar #st BLOC ;
global LTYPES param_types;

#trans {
    -- symbols table for parameters
    ST st = new ST(FUNCTION^st);
    FUNC_PARAMETERS^st = st;
    BLOC^st = st;

    -- management of parameters
    param_types = new LTYPES();
    FUNC_PARAMETERS^types = param_types;
    FUNC_PARAMETERS^locator = FUNCTION^machine.getParametersLocator();
}

#st {
    INFO i = FUNCTION^st.localSearch(ident^txt);

    if (i != null) {
        error(VAR_exists, ident^txt);
    }
    else {
        TFUNCTION fun = new TFUNCTION(ident^txt, TYPE^type, param_types);
        FUNCTION^st.insert(ident^txt, new INFOFUN(fun));
        FUNCTION^st.setCurrentFunction(fun);
    }
}

-- functions parameters
FUNC_PARAMETERS -> ;

FUNC_PARAMETERS -> FUNC_PARAMETER #trans FUNC_PARAMETERSX ;
#trans {
    STRING param_name = FUNC_PARAMETER^name;
    TTYPE param_type = FUNC_PARAMETER^type;

    FUNC_PARAMETERS^types.add(param_type);
    FUNC_PARAMETERSX^types = FUNC_PARAMETERS^types;

    -- useless, there is no other arguments for now
    INFO i = FUNC_PARAMETERS^st.localSearch(param_name);

    if (i != null) {
        error(PARAM_exists, param_name);
    }
    else {
        Location loc = FUNC_PARAMETERS^locator.generate(param_type);
        INFOVAR info = new INFOVAR(param_type, loc);
        FUNC_PARAMETERS^st.insert(param_name, info);
    }
}

FUNC_PARAMETERSX -> ;
FUNC_PARAMETERSX -> comma FUNC_PARAMETER #trans FUNC_PARAMETERSX ;
#trans {
    STRING param_name = FUNC_PARAMETER^name;
    TTYPE param_type = FUNC_PARAMETER^type;

    FUNC_PARAMETERSX^types.add(param_type);
    FUNC_PARAMETERSX1^types = FUNC_PARAMETERSX^types;

    INFO i = FUNC_PARAMETERSX^st.localSearch(param_name);

    if (i != null) {
        error(PARAM_exists, param_name);
    }
    else {
        Location loc = FUNC_PARAMETERSX^locator.generate(param_type);
        INFOVAR info = new INFOVAR(param_type, loc);
        FUNC_PARAMETERSX^st.insert(param_name, info);
    }
}

FUNC_PARAMETER -> TYPE ident #type ;
#type {
    FUNC_PARAMETER^type = TYPE^type;
    FUNC_PARAMETER^name = ident^txt;
}

-- base types and pointers
TYPE -> STYPE #trans REFS #type ;
#trans {
    REFS^htype = STYPE^type;
}

#type {
    TYPE^type = REFS^type;
}

REFS -> #type ;
#type {
    REFS^type = REFS^htype;
}

REFS -> mult #trans REFS #type ;
#trans {
    REFS1^htype = new TPOINTER(REFS^htype, REFS^machine.getPointerSize());
}

#type {
    REFS^type = REFS1^type;
}

-- base types
STYPE -> void #type ;
#type {
    STYPE^type = new TVOID();
}

STYPE -> int #type ;
#type {
    STYPE^type = new TINTEGER(STYPE^machine.getIntSize());
}

STYPE -> char #type ;
#type {
    STYPE^type = new TCHAR(STYPE^machine.getCharSize());
}

STYPE -> bool #type ;
#type {
    STYPE^type = new TBOOL(STYPE^machine.getBoolSize());
}

-- method body and instructions blocks
BLOC -> ocbra #trans INSTS ccbra #gen ;
global ST st;

#trans {
    st = new ST(BLOC^st);
    INSTS^st = st;
}

#gen {
    -- debug
    if (BLOC^source.getVerbosity() >= 2) {
        write("### symbols table ###\n");
        write(st);
        write("#####################\n");
    }
}

-- instructions
INSTS -> ;
INSTS -> INST INSTS ;

-- local variable declaration with or without initialization
INST -> TYPE ident #trans EX semicolon #gen ;
#trans {
    EX^htype = TYPE^type;
}

#gen {
    INFO i = INST^st.localSearch(ident^txt);

    if (i != null) {
        error(VAR_exists, ident^txt);
    }
    else {
        INFOVAR info = new INFOVAR(TYPE^type, null);
        INST^st.insert(ident^txt, info);
    }
}

-- expression instruction (affectation and procedure call)
INST -> E semicolon ;

-- instruction block
INST -> BLOC ;

-- conditional
INST -> if opar E cpar #type BLOC ELSE ;
#type {
    if (!E^type.testable()) {
        error(TYPE_not_bool, E^type);
    }
}

ELSE -> else BLOC ;
ELSE -> ;

-- function return
INST -> return E semicolon #gen ;
#gen {
    TTYPE return_type = INST^st.getCurrentFunction().getReturnType();
    if (!return_type.constructFrom(E^type)) {
        error(TYPES_incompatible, return_type, E^type);
    }
}

-- inline asm
INST -> asm #st ASM #gen ;
#st {
    ASM^asm_st = INST^st;
}

#gen {
    -- ASM^code_asm contains the inline assembly in which variable
    -- names have been replaced by their addresses
}

-- expressions
-----------------------------------------------------------------------
-- E = expression (including affectation)
-- A = expression figuring in an affectation
-- R = expression figuring in a relational expression
-- T = expression figuring in an additive expression (TERME)
-- F = expression figuring in a multiplicative expression (FACTOR)
-----------------------------------------------------------------------

-- affectation
E -> A #trans EX #gen ;
#trans {
    EX^htype = A^type;
}

#gen {
    E^type = EX^type;
}

EX -> affect A #gen ;
#gen {
    if (!EX^htype.constructFrom(A^type)) {
        error(TYPES_incompatible, EX^htype, A^type);
    }

    EX^type = A^type;
}

EX -> #gen ;
#gen {
    EX^type = EX^htype;
}

-- relation
A -> R #trans AX #gen ;
#trans {
    AX^htype = R^type;
}

#gen {
    A^type = AX^type;
}

AX -> OPREL R #gen ;
#gen {
    if (!AX^htype.comparableWith(R^type, OPREL^name)) {
        error(TYPES_incomparable, AX^htype, R^type, OPREL^name);
    }

    AX^type = new TBOOL(AX^machine.getBoolSize());
}

AX -> #gen ;
#gen {
    AX^type = AX^htype;
}

-- relation operators
OPREL -> inf #name ;
#name { OPREL^name = "<"; }

OPREL -> sup #name ;
#name { OPREL^name = ">"; }

OPREL -> infeq #name ;
#name { OPREL^name = "<="; }

OPREL -> supeq #name ;
#name { OPREL^name = ">="; }

OPREL -> eq #name ;
#name { OPREL^name = "=="; }

OPREL -> neq #name ;
#name { OPREL^name = "!="; }

-- additions
R -> T #trans RX #gen ;
#trans {
    RX^htype = T^type;
}

#gen {
    R^type = RX^type;
}

RX -> OPADD T #trans RX #gen ;
#trans {
    if (!RX^htype.binaryUsable(T^type, OPADD^name)) {
        error(TYPES_binary_unusable, RX^htype, T^type, OPADD^name);
    }

    RX1^htype = RX^htype;
}

#gen {
    RX^type = RX1^type;
}

RX -> #gen ;
#gen {
    RX^type = RX^htype;
}

-- addition operators
OPADD -> plus #name ;
#name { OPADD^name = "+"; }

OPADD -> minus #name ;
#name { OPADD^name = "-"; }

OPADD -> or #name ;
#name { OPADD^name = "||"; }

-- multiplications
T -> F #trans TX #gen ;
#trans {
    TX^htype = F^type;
}

#gen {
    T^type = TX^type;
}

TX -> OPMUL F #trans TX #gen ;
#trans {
    if (!TX^htype.binaryUsable(F^type, OPMUL^name)) {
        error(TYPES_binary_unusable, TX^htype, F^type, OPMUL^name);
    }

    TX1^htype = TX^htype;
}

#gen {
    TX^type = TX1^type;
}

TX -> #gen ;
#gen {
    TX^type = TX^htype;
}

-- multiplication operators
OPMUL -> mult #name ;
#name { OPMUL^name = "*"; }

OPMUL -> div #name ;
#name { OPMUL^name = "/"; }

OPMUL -> mod #name ;
#name { OPMUL^name = "%"; }

OPMUL -> and #name ;
#name { OPMUL^name = "&&"; }

-- base expressions
F -> integer #gen ;
#gen {
    F^type = new TINTEGER(F^machine.getIntSize());
}

F -> string #gen ;
#gen {
    F^type = new TPOINTER(new TCHAR(F^machine.getCharSize()), F^machine.getPointerSize());
}

F -> character #gen ;
#gen {
    F^type = new TCHAR(F^machine.getCharSize());
}

F -> null #gen ;
#gen {
    F^type = new TNULL();
}

F -> true #gen ;
#gen {
    F^type = new TBOOL(F^machine.getBoolSize());
}

F -> false #gen ;
#gen {
    F^type = new TBOOL(F^machine.getBoolSize());
}

F -> OPUN F #gen ;
#gen {
    if (!F1^type.unaryUsable(OPUN^name)) {
        error(TYPE_unary_unusable, F1^type, OPUN^name);
    }

    F^type = F1^type;
}

-- unary expressions
OPUN -> plus #name ;
#name { OPUN^name = "+"; }

OPUN -> minus #name ;
#name { OPUN^name = "-"; }

OPUN -> not #name ;
#name { OPUN^name = "!"; }

-- parenthesised expression
F -> opar E cpar #gen ;
#gen {
    F^type = E^type;
}

F -> opar TYPE cpar F #gen ;
#gen {
    -- TODO: check type for cast
    F^type = TYPE^type;
}

-- subprogram call
F -> ident opar #hgen ARGS cpar #gen ;
global LTYPES args_types;

#hgen {
    args_types = new LTYPES();
    ARGS^types = args_types;

    -- search for the function in the symbols table
    INFO i = F^st.globalSearch(ident^txt);

    if (i == null) {
        error(FUN_undefined, ident^txt);
    }
    else {
        match (i) {
            case INFOFUN {
                INFOFUN info = i;
                ARGS^function = info.getType();
                F^type = info.getType().getReturnType();
            }
            default {
                error(INFO_not_fun, ident^txt);
            }
        }
    }
}

#gen {
}

F -> ident #gen ;
#gen {
    INFO i = F^st.globalSearch(ident^txt);

    if (i == null) {
        error(VAR_undefined, ident^txt);
    }
    else {
        match (i) {
            case INFOVAR {
                INFOVAR info = i;
                F^type = info.getType();
            }
            default {
                error(INFO_not_var, ident^txt);
            }
        }
    }
}

-- pointed-to memory access
F -> mult F #gen ;
#gen {
    match (F1^type) {
        case TPOINTER {
            TPOINTER p = F1^type;
            F^type = p.getType();
        }
        default {
            error(TYPE_not_pointer, F1^type);
        }
    }
}

-- subprogram call arguments
ARGS -> #gen ;
#gen {
    if(ARGS^types.size() < ARGS^function.getParameterTypes().size()) {
        error(ARGS_too_few_arguments, ARGS^function.getName());
    }
}

ARGS -> E #trans ARGSX ;
#trans {
    ARGS^types.add(E^type);
    ARGSX^types = ARGS^types;

    if(ARGS^types.size() > ARGS^function.getParameterTypes().size()) {
        error(ARGS_too_many_arguments, ARGS^function.getName());
    }
    else {
        TTYPE needed_type = ARGS^function.getParameterTypes().get(ARGS^types.size() - 1);
        if (!needed_type.constructFrom(E^type)) {
            error(TYPES_incompatible, needed_type, E^type);
        }
    }
}

ARGSX -> #gen ;
#gen {
    if(ARGSX^types.size() < ARGSX^function.getParameterTypes().size()) {
        error(ARGS_too_few_arguments, ARGSX^function.getName());
    }
}

ARGSX -> comma E #trans ARGSX ;
#trans {
    ARGSX^types.add(E^type);
    ARGSX1^types = ARGSX^types;

    if(ARGSX^types.size() > ARGSX^function.getParameterTypes().size()) {
        error(ARGS_too_many_arguments, ARGSX^function.getName());
    }
    else {
        TTYPE needed_type = ARGSX^function.getParameterTypes().get(ARGSX^types.size() - 1);
        if (!needed_type.constructFrom(E^type)) {
            error(TYPES_incompatible, needed_type, E^type);
        }
    }
}

----============ MOC extension =================
--ENTITIES -> IMPLEMENTATION ENTITIES ;
---- class definition
--IMPLEMENTATION -> class class_ident SUPER ocbra ATTRIBUTES ccbra METHODS end ;
---- superclass
--SUPER -> ;
--SUPER -> colon class_ident ;
---- attributes
--ATTRIBUTES -> ;
--ATTRIBUTES -> TYPE ident semicolon ATTRIBUTES ;
---- methods
--METHODS -> ;
--METHODS -> METHOD METHODS ;
--METHOD -> QUAL PTYPE MFUNC_PARAMETERS BLOC ;
---- method or attribute qualifier: + = class, - = instance
--QUAL -> plus ;
--QUAL -> minus ;
---- type class
--STYPE-> class_ident ;
---- type BOOL
--STYPE-> bool ;
---- type "any"
--TYPE -> id ;
---- method return type between parentheses
--PTYPE-> opar TYPE cpar ;
---- method parameters
--MFUNC_PARAMETERS -> ;
--MFUNC_PARAMETERS -> MFUNC_PARAMETER MFUNC_PARAMETERS ;
---- selector without parameters
--MFUNC_PARAMETER -> ident ;
---- selector  + parameter type + parameter name
--MFUNC_PARAMETER -> ident colon PTYPE ident ;
--F -> nil ;
--F -> yes ;
--F -> no ;
---- MOC string (starts with @)
--F -> stringo ;
--F -> self ;
--F -> super ;
---- method call
--F -> osbra F MARGS csbra ;
---- for class method call
--F -> osbra class_ident MARGS csbra ;
---- method call arguments
--MARGS -> ;
--MARGS -> MARG MARGS ;
---- selector + arg
--MARG -> ident colon E ;
---- selector without arg
--MARG -> ident ;
