-------------------------
-- MC and MOC grammars --
-------------------------

option auto = true;
option version = 0.0.1;
option k = 2;

inh source : MOCSourceFile for PROGRAM;
inh machine : IMachine for
         ENTITIES, FUNCTION, INST, BLOC, INSTS, ELSE,
         FUNC_PARAMETERS, FUNC_PARAMETER, FUNC_PARAMETERSX, ARGS, ARGSX,
         TYPE, STYPE, REFS,
         E, EX, A, AX, R, RX, T, TX, F
--       -- TODO: MOC
--       ,IMPLEMENTATION, METHODS, METHOD, ATTRIBUTES, MFUNC_PARAMETER, MFUNC_PARAMETERS, MARG, MARGS
         ;
inh st : ST for
         ENTITIES, FUNCTION, INST, BLOC, INSTS, ELSE,
         FUNC_PARAMETERS, FUNC_PARAMETER, FUNC_PARAMETERSX, ARGS, ARGSX,
         E, EX, A, AX, R, RX, T, TX, F
--       -- TODO: MOC
--       ,IMPLEMENTATION, METHODS, METHOD, ATTRIBUTES, MFUNC_PARAMETER, MFUNC_PARAMETERS, MARG, MARGS
         ;
inh types : LTYPES for FUNC_PARAMETERS, FUNC_PARAMETERSX;
syn type : TTYPE for TYPE, FUNC_PARAMETER, STYPE, REFS;
inh htype : TTYPE for REFS;

-- these attributes allow to get inline assembly
syn asm_code : STRING for ASM;
inh asm_st : ST for ASM;

space separator  is  "[\r\n\t ]+" ;
space comm       is  "\/\/[^\n]*\n" ;
sugar opar       is  "\(" ;
sugar cpar       is  "\)" ;
sugar ocbra      is  "\{" ;
sugar ccbra      is  "\}" ;
sugar comma      is  "," ;
sugar semicolon  is  "\;" ;
sugar affect     is  "=" ;
sugar if         is  "if" ;
sugar else       is  "else" ;
sugar void       is  "void" ;
sugar asm        is  "asm" ;
sugar int        is  "int" ;
sugar char       is  "char" ;
sugar return     is  "return" ;
sugar null       is  "NULL" ;
sugar nil        is  "nil" ;
sugar inf        is  "\<" ;
sugar infeq      is  "\<=" ;
sugar sup        is  "\>" ;
sugar supeq      is  "\>=" ;
sugar eq         is  "==" ;
sugar neq        is  "\!=" ;
sugar plus       is  "\+" ;
sugar minus      is  "\-" ;
sugar or         is  "\|\|" ;
sugar and        is  "\&\&" ;
sugar mult       is  "\*" ;
sugar div        is  "\/" ;
sugar mod        is  "\%" ;
sugar not        is  "\!" ;

---- TODO: MOC
--sugar colon      is  "\:" ;
--sugar osbra      is  "\[" ;
--sugar csbra      is  "\]" ;
--sugar id         is  "id" ;
--sugar class      is  "@class" ;
--sugar end        is  "@end" ;
--sugar self       is "self" ;
--sugar bool       is  "BOOL" ;
--sugar super      is "super" ;
--sugar yes        is "YES" ;
--sugar no         is "NO" ;

term integer     is  "[0-9]+" ;
term character   is  "\'[^\']\'" ;
term string      is  "\"[^\"]*\"" ;
term ident       is  "[a-z][_0-9A-Za-z]*" ;
---- TODO: MOC
--term class_ident is  "[A-Z][_0-9A-Za-z]*" ; -- class name
--term stringo     is  "@\"[^\"]*\"" ; -- MOC string

-- for inline assembly
compil ASM;


PROGRAM -> #init ENTITIES #gen ;
global
    IMachine machine;
    ST st;

#init {
    machine = PROGRAM^source.getMachine();

    if (machine == null) {
        error(NO_MACH, PROGRAM^source.getMachName());
    }
    else {
        ENTITIES^machine = machine;
    }

    st = new ST();
    ENTITIES^st = st;
}

#gen {
    -- debug
    if (PROGRAM^source.getVerbosity() >= 1) {
        write("### final symbols table ###\n");
        write(st);
        write("###########################\n");
    }

    -- write in a file
    machine.writeCode(PROGRAM^source.getFileName(), "; no code\n");
}

ENTITIES -> ;
ENTITIES -> asm #st ASM ENTITIES #gen ;
#st {
    ASM^asm_st = ENTITIES^st;
}

#gen {
    -- ASM^asm_code contains the inline assembly
}

ENTITIES -> FUNCTION ENTITIES ;

-- functions
FUNCTION -> TYPE ident opar #trans FUNC_PARAMETERS cpar #st BLOC ;
global LTYPES param_types;

#trans {
    param_types = new LTYPES();
    FUNC_PARAMETERS^types = param_types;
}

#st {
    INFO i = FUNCTION^st.localSearch(ident^txt);

    if (i != null) {
        error(VAR_exists, ident^txt);
    }
    else {
        TFUNCTION fun = new TFUNCTION(ident^txt, TYPE^type, param_types);
        FUNCTION^st.insert(ident^txt, new INFOFUN(fun));
    }
}

-- functions parameters
FUNC_PARAMETERS -> ;

FUNC_PARAMETERS -> FUNC_PARAMETER #trans FUNC_PARAMETERSX ;
#trans {
    FUNC_PARAMETERS^types.add(FUNC_PARAMETER^type);
    FUNC_PARAMETERSX^types = FUNC_PARAMETERS^types;
}

FUNC_PARAMETERSX -> ;
FUNC_PARAMETERSX -> comma FUNC_PARAMETER #trans FUNC_PARAMETERSX ;
#trans {
    FUNC_PARAMETERSX^types.add(FUNC_PARAMETER^type);
    FUNC_PARAMETERSX1^types = FUNC_PARAMETERSX^types;
}

FUNC_PARAMETER -> TYPE ident #type ;
#type {
    FUNC_PARAMETER^type = TYPE^type;
}

-- base types and pointers
TYPE -> STYPE #trans REFS #type ;
#trans {
    REFS^htype = STYPE^type;
}

#type {
    TYPE^type = REFS^type;
}

REFS -> #type ;
#type {
    REFS^type = REFS^htype;
}

REFS -> mult #trans REFS #type ;
#trans {
    REFS1^htype = new TPOINTER(REFS^htype, REFS^machine.getPointerSize());
}

#type {
    REFS^type = REFS1^type;
}

-- base types
STYPE -> void #type ;
#type {
    STYPE^type = new TVOID();
}

STYPE -> int #type ;
#type {
    STYPE^type = new TINTEGER(STYPE^machine.getIntSize());
}

STYPE -> char #type ;
#type {
    STYPE^type = new TCHAR(STYPE^machine.getCharSize());
}

-- method body and instructions blocks
BLOC -> ocbra INSTS ccbra ;

-- instructions
INSTS -> ;
INSTS -> INST INSTS ;

-- local variable declaration with or without initialization
INST -> TYPE ident EX semicolon ;

-- expression instruction (affectation and procedure call)
INST -> E semicolon ;

-- instruction block
INST -> BLOC ;

-- conditional
INST -> if opar E cpar BLOC ELSE ;
ELSE -> else BLOC ;
ELSE -> ;

-- function return
INST -> return E semicolon ;

-- inline asm
INST -> asm #st ASM #gen ;
#st {
    ASM^asm_st = INST^st;
}

#gen {
    -- ASM^code_asm contains the inline assembly in which variable
    -- names have been replaced by their addresses
}

-- expressions
-----------------------------------------------------------------------
-- E = expression (including affectation)
-- A = expression figuring in an affectation
-- R = expression figuring in a relational expression
-- T = expression figuring in an additive expression (TERME)
-- F = expression figuring in a multiplicative expression (FACTOR)
-----------------------------------------------------------------------

-- affectation
E -> A EX ;
EX -> affect A ;
EX -> ;

-- relation
A -> R AX ;
AX -> OPREL R ;
AX -> ;

-- relation operators
OPREL -> inf ;
OPREL -> sup ;
OPREL -> infeq ;
OPREL -> supeq ;
OPREL -> eq ;
OPREL -> neq ;

-- additions
R -> T RX ;
RX -> OPADD T RX ;
RX -> ;

-- addition operators
OPADD -> plus ;
OPADD -> minus ;
OPADD -> or ;

-- multiplications
T -> F TX ;
TX -> OPMUL F TX ;
TX -> ;

-- multiplication operators
OPMUL -> mult ;
OPMUL -> div ;
OPMUL -> mod ;
OPMUL -> and ;

-- base expressions
F -> integer ;
F -> string ;
F -> character ;
F -> null ;
F -> OPUN F ;

-- unary expressions
OPUN -> plus ;
OPUN -> minus ;
OPUN -> not ;

-- parenthesised expression
F -> opar E cpar ;
F -> opar TYPE cpar F ;

-- subprogram call
F -> ident opar ARGS cpar ;
F -> ident ;

-- pointed-to memory access
F -> mult F ;

-- subprogram call arguments
ARGS -> ;
ARGS -> E ARGSX ;
ARGSX -> ;
ARGSX -> comma E ARGSX ;

----============ MOC extension =================
--ENTITIES -> IMPLEMENTATION ENTITIES ;
---- class definition
--IMPLEMENTATION -> class class_ident SUPER ocbra ATTRIBUTES ccbra METHODS end ;
---- superclass
--SUPER -> ;
--SUPER -> colon class_ident ;
---- attributes
--ATTRIBUTES -> ;
--ATTRIBUTES -> TYPE ident semicolon ATTRIBUTES ;
---- methods
--METHODS -> ;
--METHODS -> METHOD METHODS ;
--METHOD -> QUAL PTYPE MFUNC_PARAMETERS BLOC ;
---- method or attribute qualifier: + = class, - = instance
--QUAL -> plus ;
--QUAL -> minus ;
---- type class
--STYPE-> class_ident ;
---- type BOOL
--STYPE-> bool ;
---- type "any"
--TYPE -> id ;
---- method return type between parentheses
--PTYPE-> opar TYPE cpar ;
---- method parameters
--MFUNC_PARAMETERS -> ;
--MFUNC_PARAMETERS -> MFUNC_PARAMETER MFUNC_PARAMETERS ;
---- selector without parameters
--MFUNC_PARAMETER -> ident ;
---- selector  + parameter type + parameter name
--MFUNC_PARAMETER -> ident colon PTYPE ident ;
--F -> nil ;
--F -> yes ;
--F -> no ;
---- MOC string (starts with @)
--F -> stringo ;
--F -> self ;
--F -> super ;
---- method call
--F -> osbra F MARGS csbra ;
---- for class method call
--F -> osbra class_ident MARGS csbra ;
---- method call arguments
--MARGS -> ;
--MARGS -> MARG MARGS ;
---- selector + arg
--MARG -> ident colon E ;
---- selector without arg
--MARG -> ident ;
