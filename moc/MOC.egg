-------------------------
-- MC and MOC grammars --
-------------------------

option auto = true;
option version = 0.0.1;
option k = 2;

inh source : MOCSourceFile for
         PROGRAM, ENTITIES, FUNCTION, INST, BLOC, INSTS, ELSE,
         FUNC_PARAMETERS, FUNC_PARAMETER, FUNC_PARAMETERSX, ARGS, ARGSX, AFF,
         E, EX, A, AX, R, RX, T, TX, F,
         IMPLEMENTATION, METHODS, ATTRIBUTES, MFUNC_PARAMETER, MFUNC_PARAMETERS, MARG, MARGS;
inh machine : IMachine for
         ENTITIES, FUNCTION, INST, BLOC, INSTS, ELSE,
         FUNC_PARAMETERS, FUNC_PARAMETER, FUNC_PARAMETERSX, ARGS, ARGSX, AFF,
         TYPE, STYPE, PTYPE, REFS,
         E, EX, A, AX, R, RX, T, TX, F,
         IMPLEMENTATION, METHODS, ATTRIBUTES, MFUNC_PARAMETER, MFUNC_PARAMETERS, MARG, MARGS;
inh st : ST for
         ENTITIES, FUNCTION, INST, BLOC, INSTS, ELSE,
         FUNC_PARAMETERS, FUNC_PARAMETER, FUNC_PARAMETERSX, ARGS, ARGSX, AFF,
         TYPE, STYPE, PTYPE, SUPER,
         E, EX, A, AX, R, RX, T, TX, F,
         IMPLEMENTATION, METHODS, ATTRIBUTES, MFUNC_PARAMETER, MFUNC_PARAMETERS, MARG, MARGS;
inh types : LTYPES for FUNC_PARAMETERS, FUNC_PARAMETERSX, ARGS, ARGSX;
syn type : TTYPE for
         TYPE, STYPE, PTYPE, REFS, FUNC_PARAMETER,
         E, EX, A, AX, R, RX, T, TX, F;
inh htype : TTYPE for REFS, EX, AX, RX, TX, AFF;
inh hinfo : INFOVAR for AFF;
syn name : STRING for OPREL, OPADD, OPMUL, OPUN, FUNC_PARAMETER;
inh plocator : ParametersLocator for FUNC_PARAMETERS, FUNC_PARAMETERSX;
inh vlocator : VariableLocator for BLOC, INSTS, INST, ELSE;
syn class : TCLASS for SUPER;
syn static : BOOLEAN for QUAL;

syn field : FIELD for MFUNC_PARAMETER, MARG;
inh hfields : LFIELDS for ATTRIBUTES, MFUNC_PARAMETERS, MARGS;
inh hmethods : LMETHODS for METHODS;

syn code : Code for 
         ENTITIES, FUNCTION, INST, BLOC, INSTS, ELSE,
         ARGS, ARGSX, AFF,
         E, EX, A, AX, R, RX, T, TX, F,
         IMPLEMENTATION, METHODS;
inh hcode : Code for 
         EX, AX, RX, TX , ARGSX;

-- to check subprogram call
inh function : TFUNCTION for ARGS, ARGSX;

space separator  is  "[\r\n\t ]+" ;
space comm       is  "\/\/[^\n]*\n" ;
sugar opar       is  "\(" ;
sugar cpar       is  "\)" ;
sugar ocbra      is  "\{" ;
sugar ccbra      is  "\}" ;
sugar comma      is  "," ;
sugar semicolon  is  "\;" ;
sugar affect     is  "=" ;
sugar if         is  "if" ;
sugar else       is  "else" ;
sugar while      is  "while" ;
sugar void       is  "void" ;
sugar asm        is  "asm" ;
sugar int        is  "int" ;
sugar char       is  "char" ;
sugar bool       is  "bool" ;
sugar true       is  "true" ;
sugar false      is  "false" ;
sugar return     is  "return" ;
sugar null       is  "NULL" ;
sugar nil        is  "nil" ;
sugar inf        is  "\<" ;
sugar infeq      is  "\<=" ;
sugar sup        is  "\>" ;
sugar supeq      is  "\>=" ;
sugar eq         is  "==" ;
sugar neq        is  "\!=" ;
sugar plus       is  "\+" ;
sugar minus      is  "\-" ;
sugar or         is  "\|\|" ;
sugar and        is  "\&\&" ;
sugar mult       is  "\*" ;
sugar div        is  "\/" ;
sugar mod        is  "\%" ;
sugar not        is  "\!" ;
sugar colon      is  "\:" ;
sugar osbra      is  "\[" ;
sugar csbra      is  "\]" ;
sugar id         is  "id" ;
sugar class      is  "@class" ;
sugar t_end      is  "@end" ;
sugar self       is  "self" ;
sugar super      is  "super" ;
--sugar bool       is  "BOOL" ;
--sugar yes        is "YES" ;
--sugar no         is "NO" ;

term integer     is  "[0-9]+" ;
term character   is  "\'([^\']|\\[0nrt])\'" ;
term string      is  "\"[^\"]*\"" ;
term ident       is  "[a-z][_0-9A-Za-z]*" ;
term class_ident is  "[A-Z][_0-9A-Za-z]*" ; -- class name
--term stringo     is  "@\"[^\"]*\"" ; -- MOC string


PROGRAM -> #init ENTITIES #gen ;
global
    IMachine machine;
    ST st;

#init {
    machine = PROGRAM^source.getMachine();
    ENTITIES^machine = machine;

    st = new ST();
    ENTITIES^st = st;
}

#gen {
    -- debug
    if (PROGRAM^source.getVerbosity() >= 1) {
        write("### final symbols table ###\n");
        write(st);
        write("###########################\n");
    }

    -- write in a file
    machine.writeCode(PROGRAM^source.getFileName(), ENTITIES^code.getAsm());
}

ENTITIES -> #gen ;
#gen {
    ENTITIES^code = new Code("");
}

ENTITIES -> asm opar string cpar ENTITIES #gen ;
#gen {
    Code entCode = ENTITIES^machine.includeAsm(string^txt, ENTITIES^st);
    entCode.appendAsm(ENTITIES1^code.getAsm());
    ENTITIES^code = entCode;
}

ENTITIES -> FUNCTION ENTITIES #gen ;
#gen {
    Code entCode = new Code(FUNCTION^code.getAsm());
    entCode.appendAsm(ENTITIES1^code.getAsm());
    ENTITIES^code = entCode;
}


-- functions
FUNCTION -> TYPE ident opar #trans FUNC_PARAMETERS cpar #st BLOC #gen ;
global LTYPES param_types;
    TFUNCTION fun;

#trans {
    -- symbols table for parameters
    ST st = new ST(FUNCTION^st);
    FUNC_PARAMETERS^st = st;
    BLOC^st = st;

    -- variable locator
    BLOC^vlocator = FUNCTION^machine.getVariableLocator();

    -- management of parameters
    param_types = new LTYPES();
    FUNC_PARAMETERS^types = param_types;
    FUNC_PARAMETERS^plocator = FUNCTION^machine.getParametersLocator();
}

#st {
    INFO i = FUNCTION^st.localSearch(ident^txt);

    if (i != null) {
        error(VAR_exists, ident^txt);
    }
    else {
        fun = new TFUNCTION(ident^txt, TYPE^type, param_types);
        FUNCTION^st.insert(ident^txt, new INFOFUN(fun));
        FUNCTION^st.setCurrentFunction(fun);
    }
}

#gen {
    FUNCTION^code = FUNCTION^machine.genFunction(fun, BLOC^code);
    FUNCTION^st.setCurrentFunction(null);
}

-- functions parameters
FUNC_PARAMETERS -> ;

FUNC_PARAMETERS -> FUNC_PARAMETER #trans FUNC_PARAMETERSX ;
#trans {
    STRING param_name = FUNC_PARAMETER^name;
    TTYPE param_type = FUNC_PARAMETER^type;

    FUNC_PARAMETERS^types.add(param_type);
    FUNC_PARAMETERSX^types = FUNC_PARAMETERS^types;

    -- useless, there is no other arguments for now
    INFO i = FUNC_PARAMETERS^st.localSearch(param_name);

    if (i != null) {
        error(PARAM_exists, param_name);
    }
    else {
        Location loc = FUNC_PARAMETERS^plocator.generate(param_type);
        INFOVAR info = new INFOVAR(param_type, loc);
        FUNC_PARAMETERS^st.insert(param_name, info);
    }
}

FUNC_PARAMETERSX -> ;
FUNC_PARAMETERSX -> comma FUNC_PARAMETER #trans FUNC_PARAMETERSX ;
#trans {
    STRING param_name = FUNC_PARAMETER^name;
    TTYPE param_type = FUNC_PARAMETER^type;

    FUNC_PARAMETERSX^types.add(param_type);
    FUNC_PARAMETERSX1^types = FUNC_PARAMETERSX^types;

    -- check if the parameter already exists
    INFO i = FUNC_PARAMETERSX^st.localSearch(param_name);

    if (i != null) {
        error(PARAM_exists, param_name);
    }
    else {
        Location loc = FUNC_PARAMETERSX^plocator.generate(param_type);
        INFOVAR info = new INFOVAR(param_type, loc);
        FUNC_PARAMETERSX^st.insert(param_name, info);
    }
}

FUNC_PARAMETER -> TYPE ident #type ;
#type {
    FUNC_PARAMETER^type = TYPE^type;
    FUNC_PARAMETER^name = ident^txt;
}

-- base types and pointers
TYPE -> STYPE #trans REFS #type ;
#trans {
    REFS^htype = STYPE^type;
}

#type {
    TYPE^type = REFS^type;
}

REFS -> #type ;
#type {
    REFS^type = REFS^htype;
}

REFS -> mult #trans REFS #type ;
#trans {
    match (REFS^htype) {
        case TCLASS {
            -- type TINSTANCE
            TCLASS class = REFS^htype;
            REFS1^htype = new TINSTANCE(class, REFS^machine.getPointerSize());
        }
        default {
            -- type TPOINTER
            REFS1^htype = new TPOINTER(REFS^htype, REFS^machine.getPointerSize());
        }
    }
}

#type {
    REFS^type = REFS1^type;
}

-- base types
STYPE -> void #type ;
#type {
    STYPE^type = new TVOID();
}

STYPE -> int #type ;
#type {
    STYPE^type = new TINTEGER(STYPE^machine.getIntSize());
}

STYPE -> char #type ;
#type {
    STYPE^type = new TCHAR(STYPE^machine.getCharSize());
}

STYPE -> bool #type ;
#type {
    STYPE^type = new TBOOL(STYPE^machine.getBoolSize());
}

-- method body and instructions blocks
BLOC -> ocbra #trans INSTS ccbra #gen ;
global ST st;

#trans {
    st = new ST(BLOC^st);
    INSTS^st = st;
}

#gen {
    BLOC^code = BLOC^machine.genBloc(INSTS^code, BLOC^vlocator);

    -- debug
    if (BLOC^source.getVerbosity() >= 2) {
        write("### symbols table ###\n");
        write(st);
        write("#####################\n");
    }
}

-- instructions
INSTS -> #gen ;
#gen {
    INSTS^code = new Code("");
}

INSTS -> INST INSTS #gen ;
#gen {
    Code c = INST^code;
    c.appendAsm(INSTS1^code.getAsm());
    INSTS^code = c;
}

-- local variable declaration with or without initialization
INST -> TYPE ident #trans AFF semicolon #gen ;
#trans {
    AFF^htype = TYPE^type;
    
    -- check if the variable already exists
    INFO i = INST^st.localSearch(ident^txt);

    if (i != null) {
        error(VAR_exists, ident^txt);
    }
    else {
        INFOVAR info = new INFOVAR(TYPE^type, INST^vlocator.generate(TYPE^type));
        INST^st.insert(ident^txt, info);
        AFF^hinfo = info;
    }
}

#gen {
    INST^code = AFF^code;
}

AFF -> affect A #gen ;
#gen {
    if (!AFF^htype.constructFrom(A^type)) {
        error(TYPES_incompatible, AFF^htype, A^type);
    }

    AFF^code = AFF^machine.genDecl(AFF^hinfo, A^code);
}

AFF -> #gen ;
#gen {
    AFF^code = AFF^machine.genDecl(AFF^hinfo);
}

-- expression instruction (affectation and procedure call)
INST -> E semicolon #gen ;
#gen {
    INST^code = INST^machine.genInst(E^type, E^code);
}

-- instruction block
INST -> #trans BLOC #gen ;
#trans {
    BLOC^vlocator = INST^vlocator.getChild();
}

#gen {
    INST^code = BLOC^code;
}

-- conditional
INST -> if opar E cpar #trans BLOC ELSE #gen ;
#trans {
    if (!E^type.testable()) {
        error(TYPE_not_bool, E^type);
    }

    BLOC^vlocator = INST^vlocator.getChild();
    ELSE^vlocator = INST^vlocator.getChild();
}

#gen {
    INST^code = INST^machine.genConditional(E^code, BLOC^code, ELSE^code);
}

ELSE -> else BLOC #gen ;
#gen {
    ELSE^code = BLOC^code;
}

ELSE -> #gen ;
#gen {
    ELSE^code = new Code("");
}

-- loop
INST -> while opar E cpar #trans BLOC #gen ;
#trans {
    if (!E^type.testable()) {
        error(TYPE_not_bool, E^type);
    }

    BLOC^vlocator = INST^vlocator.getChild();
}

#gen {
    INST^code = INST^machine.genLoop(E^code, BLOC^code);
}

-- function return
INST -> return E semicolon #gen ;
#gen {
    TTYPE returnType;

    -- 2 cases: function return or method return
    if (INST^st.getCurrentFunction() != null) {
        returnType = INST^st.getCurrentFunction().getReturnType();
    }
    else {
        returnType = INST^st.getCurrentMethod().getReturnType();
    }

    if (!returnType.constructFrom(E^type)) {
        error(TYPES_incompatible, returnType, E^type);
    }

    if (INST^st.getCurrentFunction() != null) {
        INST^code = INST^machine.genReturn(E^code, INST^st.getCurrentFunction());
    }
    else {
        INST^code = new Code(""); -- TODO
    }
}

-- inline asm
INST -> asm opar string cpar semicolon #gen ;
#gen {
    INST^code = INST^machine.includeAsm(string^txt, INST^st);
}

-- expressions
-----------------------------------------------------------------------
-- E = expression (including affectation)
-- A = expression figuring in an affectation
-- R = expression figuring in a relational expression
-- T = expression figuring in an additive expression (TERME)
-- F = expression figuring in a multiplicative expression (FACTOR)
-----------------------------------------------------------------------

-- affectation
E -> A #trans EX #gen ;
#trans {
    EX^htype = A^type;
    EX^hcode = A^code;
}

#gen {
    E^type = EX^type;
    E^code = EX^code;
}

EX -> affect A #gen ;
#gen {
    if (!EX^htype.constructFrom(A^type)) {
        error(TYPES_incompatible, EX^htype, A^type);
    }
    elseif (!EX^hcode.getIsAddress() && EX^hcode.getLocation() == null) {
        error(AFF_impossible);
    }

    EX^type = new TVOID();
    EX^code = EX^machine.genAffectation(EX^hcode, A^code, A^type);
}

EX -> #gen ;
#gen {
    EX^type = EX^htype;
    EX^code = EX^hcode;
}

-- relation
A -> R #trans AX #gen ;
#trans {
    AX^htype = R^type;
    AX^hcode = R^code;

}

#gen {
    A^type = AX^type;
    A^code = AX^code;
}

AX -> OPREL R #gen ;
#gen {
    if (!AX^htype.comparableWith(R^type, OPREL^name)) {
        error(TYPES_incomparable, AX^htype, R^type, OPREL^name);
    }

    AX^type = new TBOOL(AX^machine.getBoolSize());
    AX^code = AX^machine.genBinary(AX^hcode, AX^htype, R^code, R^type, OPREL^name);
}

AX -> #gen ;
#gen {
    AX^type = AX^htype;
    AX^code = AX^hcode;
}

-- relation operators
OPREL -> inf #name ;
#name { OPREL^name = "<"; }

OPREL -> sup #name ;
#name { OPREL^name = ">"; }

OPREL -> infeq #name ;
#name { OPREL^name = "<="; }

OPREL -> supeq #name ;
#name { OPREL^name = ">="; }

OPREL -> eq #name ;
#name { OPREL^name = "=="; }

OPREL -> neq #name ;
#name { OPREL^name = "!="; }

-- additions
R -> T #trans RX #gen ;
#trans {
    RX^htype = T^type;
    RX^hcode = T^code;
}

#gen {
    R^type = RX^type;
    R^code = RX^code;
}

RX -> OPADD T #trans RX #gen ;
#trans {
    if (!RX^htype.binaryUsable(T^type, OPADD^name)) {
        error(TYPES_binary_unusable, RX^htype, T^type, OPADD^name);
    }

    RX1^htype = RX^htype;
    RX1^hcode = RX^machine.genBinary(RX^hcode, RX^htype, T^code, T^type, OPADD^name);
}

#gen {
    RX^type = RX1^type;
    RX^code = RX1^code;
}

RX -> #gen ;
#gen {
    RX^type = RX^htype;
    RX^code = RX^hcode;
}

-- addition operators
OPADD -> plus #name ;
#name { OPADD^name = "+"; }

OPADD -> minus #name ;
#name { OPADD^name = "-"; }

OPADD -> or #name ;
#name { OPADD^name = "||"; }

-- multiplications
T -> F #trans TX #gen ;
#trans {
    TX^htype = F^type;
    TX^hcode = F^code;
}

#gen {
    T^type = TX^type;
    T^code = TX^code;
}

TX -> OPMUL F #trans TX #gen ;
#trans {
    if (!TX^htype.binaryUsable(F^type, OPMUL^name)) {
        error(TYPES_binary_unusable, TX^htype, F^type, OPMUL^name);
    }

    TX1^htype = TX^htype;
    TX1^hcode = TX^machine.genBinary(TX^hcode, TX^htype, F^code, F^type, OPMUL^name);
}

#gen {
    TX^type = TX1^type;
    TX^code = TX1^code;
}

TX -> #gen ;
#gen {
    TX^type = TX^htype;
    TX^code = TX^hcode;
}

-- multiplication operators
OPMUL -> mult #name ;
#name { OPMUL^name = "*"; }

OPMUL -> div #name ;
#name { OPMUL^name = "/"; }

OPMUL -> mod #name ;
#name { OPMUL^name = "%"; }

OPMUL -> and #name ;
#name { OPMUL^name = "&&"; }

-- base expressions
F -> integer #gen ;
#gen {
    F^type = new TINTEGER(F^machine.getIntSize());
    F^code = F^machine.genInt(integer^txt);
}

F -> string #gen ;
#gen {
    F^type = new TPOINTER(new TCHAR(F^machine.getCharSize()), F^machine.getPointerSize());
    F^code = F^machine.genString(string^txt);
}

F -> character #gen ;
#gen {
    F^type = new TCHAR(F^machine.getCharSize());
    F^code = F^machine.genChar(character^txt);
}

F -> null #gen ;
#gen {
    F^type = new TNULL();
    F^code = F^machine.genNull();
}

F -> true #gen ;
#gen {
    F^type = new TBOOL(F^machine.getBoolSize());
    F^code = F^machine.genBool(1);
}

F -> false #gen ;
#gen {
    F^type = new TBOOL(F^machine.getBoolSize());
    F^code = F^machine.genBool(0);
}

F -> OPUN F #gen ;
#gen {
    if (!F1^type.unaryUsable(OPUN^name)) {
        error(TYPE_unary_unusable, F1^type, OPUN^name);
    }

    F^type = F1^type;
    F^code = F^machine.genUnary(F1^code, F1^type, OPUN^name);
}

-- unary expressions
OPUN -> plus #name ;
#name { OPUN^name = "+"; }

OPUN -> minus #name ;
#name { OPUN^name = "-"; }

OPUN -> not #name ;
#name { OPUN^name = "!"; }

-- parenthesised expression
F -> opar E cpar #gen ;
#gen {
    F^type = E^type;
    F^code = E^code;
}

F -> opar TYPE cpar F #gen ;
#gen {
    if (F1^type.equals(TYPE^type)) {
        warning(TYPE_cast_useless, TYPE^type.toString(), TYPE^type.toString());
    }
    elseif (!F1^type.isCastableTo(TYPE^type)) {
        error(TYPE_uncastable, F1^type, TYPE^type);
    }

    F^type = TYPE^type;
    F^code = F^machine.genCast(TYPE^type, F1^code);
}

-- subprogram call
F -> ident opar #hgen ARGS cpar #gen ;
global LTYPES args_types; TFUNCTION fun;

#hgen {
    args_types = new LTYPES();
    ARGS^types = args_types;

    -- search for the function in the symbols table
    INFO i = F^st.globalSearch(ident^txt);

    if (i == null) {
        error(FUN_undefined, ident^txt);
    }
    else {
        match (i) {
            case INFOFUN {
                INFOFUN info = i;
                fun = info.getType();
                ARGS^function = fun;
                F^type = info.getType().getReturnType();
            }
            default {
                error(INFO_not_fun, ident^txt);
            }
        }
    }
}

#gen {
    F^code = F^machine.genCall(fun, ARGS^code);
}

F -> ident #gen ;
#gen {
    -- search for ident in the symbols table
    INFO i = F^st.globalSearch(ident^txt);

    if (i == null) {
        -- search for ident in class attributes
        TCLASS currentClass = F^st.getCurrentClass();

        if (currentClass != null && currentClass.findAttribute(ident^txt) != null) {
            FIELD attr = currentClass.findAttribute(ident^txt);
            INTEGER offset = currentClass.getAttributeOffset(ident^txt);

            F^type = attr.getType();
            F^code = new Code("; offset " + offset); -- TODO
            F^code.setIsAddress(true); -- TODO: to be done in a genAttribute method..
        }
        else {
            error(VAR_undefined, ident^txt);
        }
    }
    else {
        match (i) {
            case INFOVAR {
                INFOVAR info = i;
                F^type = info.getType();
                F^code = F^machine.genVariable(info);
            }
            default {
                error(INFO_not_var, ident^txt);
            }
        }
    }
}

-- pointed-to memory access
F -> mult F #gen ;
#gen {
    match (F1^type) {
        case TPOINTER {
            TPOINTER p = F1^type;
            F^type = p.getType();
            F^code = F^machine.genAcces(F1^code, p.getType());
        }
        default {
            error(TYPE_not_pointer, F1^type);
        }
    }
}

-- subprogram call arguments
ARGS -> #gen ;
#gen {
    -- check number of parameters
    if(ARGS^types.size() < ARGS^function.getParameterTypes().size()) {
        error(ARGS_too_few_arguments, ARGS^function.getName());
    }

    ARGS^code = new Code("");
}

ARGS -> E #trans ARGSX #gen;
#trans {
    ARGS^types.add(E^type);
    ARGSX^types = ARGS^types;
    ARGSX^hcode = ARGS^machine.genArg(E^code, E^type);

    -- check number of parameters
    if(ARGS^types.size() > ARGS^function.getParameterTypes().size()) {
        error(ARGS_too_many_arguments, ARGS^function.getName());
    }
    else {
        TTYPE needed_type = ARGS^function.getParameterTypes().get(ARGS^types.size() - 1);
        if (!needed_type.constructFrom(E^type)) {
            error(TYPES_incompatible, needed_type, E^type);
        }
    }
}

#gen {
    ARGS^code = ARGSX^code;
}

ARGSX -> #gen ;
#gen {
    if(ARGSX^types.size() < ARGSX^function.getParameterTypes().size()) {
        error(ARGS_too_few_arguments, ARGSX^function.getName());
    }
    ARGSX^code = ARGSX^hcode;
}

ARGSX -> comma E #trans ARGSX #gen ;
#trans {
    ARGSX^types.add(E^type);
    ARGSX1^types = ARGSX^types;

    -- check number of parameters
    if(ARGSX^types.size() > ARGSX^function.getParameterTypes().size()) {
        error(ARGS_too_many_arguments, ARGSX^function.getName());
    }
    else {
        TTYPE needed_type = ARGSX^function.getParameterTypes().get(ARGSX^types.size() - 1);
        if (!needed_type.constructFrom(E^type)) {
            error(TYPES_incompatible, needed_type, E^type);
        }
    }

    Code c = ARGSX^machine.genArg(E^code, E^type);
    c.appendAsm(ARGSX^hcode.getAsm());
    ARGSX1^hcode = c;    
}

#gen {
    ARGSX^code = ARGSX1^code;
}

--============ MOC extension =================

ENTITIES -> IMPLEMENTATION ENTITIES #gen ;
#gen {
    Code c = new Code(IMPLEMENTATION^code.getAsm());
    c.appendAsm(ENTITIES1^code.getAsm());
    ENTITIES^code = c;
}

-- class definition
IMPLEMENTATION -> class class_ident SUPER ocbra #trans ATTRIBUTES ccbra METHODS t_end #gen ;
#trans {
    if (IMPLEMENTATION^st.localSearch(class_ident^txt) != null) {
        error(VAR_exists, class_ident^txt);
    }

    -- symbols table for attributes and methods
    ST st = new ST(IMPLEMENTATION^st);
    ATTRIBUTES^st = st;
    METHODS^st = st;

    LFIELDS fields = new LFIELDS();
    ATTRIBUTES^hfields = fields;

    LMETHODS methods = new LMETHODS();
    METHODS^hmethods = methods;

    -- insert class in the current symbols table
    TCLASS class = new TCLASS(class_ident^txt, SUPER^class, fields, methods);
    IMPLEMENTATION^st.insert(class_ident^txt, new INFOCLASS(class));
    IMPLEMENTATION^st.setCurrentClass(class);
}

#gen {
    IMPLEMENTATION^code = new Code("");
    IMPLEMENTATION^st.setCurrentClass(null);
}

-- superclass
SUPER -> #class ;
#class {
    SUPER^class = null;
}

SUPER -> colon class_ident #class ;
#class {
    -- seach for class_ident in the symbols table
    INFO i = SUPER^st.globalSearch(class_ident^txt);

    if (i == null) {
        error(CLASS_undefined, class_ident^txt);
    }
    else {
        match (i) {
            case INFOCLASS {
                INFOCLASS info = i;
                SUPER^class = info.getType();
            }
            default {
                error(INFO_not_class, class_ident^txt);
            }
        }
    }
}

-- attributes
ATTRIBUTES -> ;

ATTRIBUTES -> TYPE ident semicolon #attr ATTRIBUTES ;
#attr {
    -- check if the attribute already exists in the class or some super classes
    if (ATTRIBUTES^st.getCurrentClass().findAttribute(ident^txt) != null) {
        error(ATTR_exists, ident^txt);
    }

    ATTRIBUTES^hfields.add(new FIELD(ident^txt, TYPE^type));
}

-- methods
METHODS -> #gen ;
#gen {
    METHODS^code = new Code("");
}

METHODS -> QUAL PTYPE #params MFUNC_PARAMETERS #method BLOC METHODS #gen ;
global LFIELDS fields;

#params {
    -- symbols table for parameters
    ST st = new ST(METHODS^st);
    MFUNC_PARAMETERS^st = st;
    BLOC^st = st;

    -- variable locator
    BLOC^vlocator = METHODS^machine.getVariableLocator();

    fields = new LFIELDS();
    MFUNC_PARAMETERS^hfields = fields;
}

#method {
    -- check if the method is already defined
    if (METHODS^st.getCurrentClass().findMethodByName(fields, false) != null) {
        error(METH_exists, METHODS^st.getCurrentClass().findMethodByName(fields, false));
    }

    METHOD method = new METHOD(PTYPE^type, fields, QUAL^static);
    METHODS^hmethods.add(method);
    METHODS^st.setCurrentMethod(method);
}

#gen {
    METHODS^code = new Code("");
    METHODS^st.setCurrentMethod(null);
}

-- method or attribute qualifier: + = class, - = instance
QUAL -> plus #gen ;
#gen { QUAL^static = true; }

QUAL -> minus #gen ;
#gen { QUAL^static = false; }

-- type class
STYPE -> class_ident #type ;
#type {
    -- search for class_ident in the symbols table
    INFO i = STYPE^st.globalSearch(class_ident^txt);

    if (i == null) {
        error(CLASS_undefined, class_ident^txt);
    }
    else {
        match (i) {
            case INFOCLASS {
                INFOCLASS info = i;
                STYPE^type = info.getType();
            }
            default {
                error(INFO_not_class, class_ident^txt);
            }
        }
    }
}

-- type "any"
TYPE -> id #type ;
#type {
    TYPE^type = new TID();
}

-- method return type between parentheses
PTYPE -> opar TYPE cpar #type ;
#type {
    PTYPE^type = TYPE^type;
}

-- method parameters
MFUNC_PARAMETERS -> ;

MFUNC_PARAMETERS -> MFUNC_PARAMETER #param MFUNC_PARAMETERS ;
#param {
    -- check if the parameter is already defined
    if (MFUNC_PARAMETERS^hfields.find(MFUNC_PARAMETER^field.getName()) != null) {
        error(PARAM_exists, MFUNC_PARAMETER^field.getName());
    }

    MFUNC_PARAMETERS^hfields.add(MFUNC_PARAMETER^field);
}

-- selector without parameters
MFUNC_PARAMETER -> ident #field ;
#field {
    MFUNC_PARAMETER^field = new FIELD(ident^txt, null);
}

-- selector + parameter type + parameter name
MFUNC_PARAMETER -> ident colon PTYPE ident #field ;
#field {
    MFUNC_PARAMETER^field = new FIELD(ident^txt, PTYPE^type);

    -- add ident1 in the symbols table
    INFO i = MFUNC_PARAMETER^st.localSearch(ident1^txt);

    if (i != null) {
        error(VAR_exists, ident1^txt);
    }
    else {
        Location loc = null; -- TODO
        INFOVAR info = new INFOVAR(PTYPE^type, loc);
        MFUNC_PARAMETER^st.insert(ident1^txt, info);
    }
}

--F -> nil ;
--F -> yes ;
--F -> no ;

-- MOC string (starts with @)
--F -> stringo ;

F -> self #gen ;
#gen {
    if (F^st.getCurrentMethod() == null) {
        error(SELF_outside_method);
    }
    elseif (F^st.getCurrentMethod().isStatic()) {
        error(METH_static, F^st.getCurrentClass().getName(), F^st.getCurrentMethod());
    }

    F^type = new TINSTANCE(F^st.getCurrentClass(), F^machine.getPointerSize());
    F^code = new Code("");
}

F -> super #gen ;
#gen {
    if (F^st.getCurrentMethod() == null) {
        error(SUPER_outside_method);
    }
    elseif (F^st.getCurrentMethod().isStatic()) {
        error(METH_static, F^st.getCurrentClass().getName(), F^st.getCurrentMethod());
    }
    elseif (F^st.getCurrentClass().getSuperType() == null) {
        error(SUPER_undefined);
    }

    F^type = new TINSTANCE(F^st.getCurrentClass().getSuperType(), F^machine.getPointerSize());
    F^code = new Code("");
}

-- method call
F -> osbra F #args MARGS csbra #gen ;
global LFIELDS fields;

#args {
    fields = new LFIELDS();
    MARGS^hfields = fields;
}

#gen {
    METHOD method = null;

    match (F1^type) {
        case TINSTANCE {
            TINSTANCE instance = F1^type;
            method = instance.getType().findCallableMethod(fields);

            if (method == null) {
                error(METH_undefined, instance.getType().getName(), fields);
            }
            elseif (method.isStatic()) {
                error(METH_static, instance.getType().getName(), fields);
            }
        }
        default {
            error(TYPE_not_instance, F1^type);
        }
    }

    F^type = method.getReturnType();
    F^code = new Code("");
}

-- for class method call
F -> osbra class_ident #args MARGS csbra #gen ;
global TCLASS class;
    LFIELDS fields;

#args {
    INFO i = F^st.globalSearch(class_ident^txt);

    if (i == null) {
        error(CLASS_undefined, class_ident^txt);
    }
    else {
        match (i) {
            case INFOCLASS {
                INFOCLASS info = i;
                class = info.getType();
            }
            default {
                error(INFO_not_class, class_ident^txt);
            }
        }
    }

    fields = new LFIELDS();
    MARGS^hfields = fields;
}

#gen {
    METHOD method = class.findCallableMethod(fields);

    if (method == null) {
        error(METH_undefined, class.getName(), fields);
    }
    elseif (!method.isStatic()) {
        error(METH_not_static, class.getName(), fields);
    }

    F^type = method.getReturnType();
    F^code = new Code("");
}

-- method call arguments
MARGS -> ;

MARGS -> MARG #args MARGS ;
#args {
    -- check if the parameter is already defined
    if (MARGS^hfields.find(MARG^field.getName()) != null) {
        error(PARAM_exists, MARG^field.getName());
    }

    MARGS^hfields.add(MARG^field);
}

-- selector + arg
MARG -> ident colon E #arg ;
#arg {
    MARG^field = new FIELD(ident^txt, E^type);
}

-- selector without arg
MARG -> ident #arg ;
#arg {
    MARG^field = new FIELD(ident^txt, null);
}
