-------------------------
-- MC and MOC grammars --
-------------------------

option auto = true;
option version = 0.0.1;
option k = 2;

inh source : MOCSourceFile for
         PROGRAM, ENTITIES, FUNCTION, INST, BLOC, INSTS, ELSE,
         FUNC_PARAMETERS, FUNC_PARAMETER, FUNC_PARAMETERSX, ARGS, ARGSX, AFF,
         E, EX, A, AX, R, RX, T, TX, F
--       -- TODO: MOC
--       ,IMPLEMENTATION, METHODS, METHOD, ATTRIBUTES, MFUNC_PARAMETER, MFUNC_PARAMETERS, MARG, MARGS
         ;
inh machine : IMachine for
         ENTITIES, FUNCTION, INST, BLOC, INSTS, ELSE,
         FUNC_PARAMETERS, FUNC_PARAMETER, FUNC_PARAMETERSX, ARGS, ARGSX,
         TYPE, STYPE, REFS, AFF,
         E, EX, A, AX, R, RX, T, TX, F
--       -- TODO: MOC
--       ,IMPLEMENTATION, METHODS, METHOD, ATTRIBUTES, MFUNC_PARAMETER, MFUNC_PARAMETERS, MARG, MARGS
         ;
inh st : ST for
         ENTITIES, FUNCTION, INST, BLOC, INSTS, ELSE,
         FUNC_PARAMETERS, FUNC_PARAMETER, FUNC_PARAMETERSX, ARGS, ARGSX, AFF,
         E, EX, A, AX, R, RX, T, TX, F
--       -- TODO: MOC
--       ,IMPLEMENTATION, METHODS, METHOD, ATTRIBUTES, MFUNC_PARAMETER, MFUNC_PARAMETERS, MARG, MARGS
         ;
inh types : LTYPES for FUNC_PARAMETERS, FUNC_PARAMETERSX, ARGS, ARGSX;
syn type : TTYPE for
         TYPE, FUNC_PARAMETER, STYPE, REFS,
         E, EX, A, AX, R, RX, T, TX, F;
inh htype : TTYPE for REFS, EX, AX, RX, TX, AFF;
syn name : STRING for OPREL, OPADD, OPMUL, OPUN, FUNC_PARAMETER;
inh locator : ParametersLocator for FUNC_PARAMETERS, FUNC_PARAMETERSX;
inh vlocator : VariableLocator for BLOC, INSTS, INST, ELSE;

syn code : Code for 
         ENTITIES, FUNCTION, INST, BLOC, INSTS, ELSE,
         ARGS, ARGSX, AFF,
         E, EX, A, AX, R, RX, T, TX, F
         -- TODO: MOC
        ;
inh hcode : Code for 
        EX, AX, RX, TX , ARGSX
         -- TODO: MOC
        ;

-- to check subprogram call
inh function : TFUNCTION for ARGS, ARGSX;

space separator  is  "[\r\n\t ]+" ;
space comm       is  "\/\/[^\n]*\n" ;
sugar opar       is  "\(" ;
sugar cpar       is  "\)" ;
sugar ocbra      is  "\{" ;
sugar ccbra      is  "\}" ;
sugar comma      is  "," ;
sugar semicolon  is  "\;" ;
sugar affect     is  "=" ;
sugar if         is  "if" ;
sugar else       is  "else" ;
sugar void       is  "void" ;
sugar asm        is  "asm" ;
sugar int        is  "int" ;
sugar char       is  "char" ;
sugar bool       is  "bool" ;
sugar true       is  "true" ;
sugar false      is  "false" ;
sugar return     is  "return" ;
sugar null       is  "NULL" ;
sugar nil        is  "nil" ;
sugar inf        is  "\<" ;
sugar infeq      is  "\<=" ;
sugar sup        is  "\>" ;
sugar supeq      is  "\>=" ;
sugar eq         is  "==" ;
sugar neq        is  "\!=" ;
sugar plus       is  "\+" ;
sugar minus      is  "\-" ;
sugar or         is  "\|\|" ;
sugar and        is  "\&\&" ;
sugar mult       is  "\*" ;
sugar div        is  "\/" ;
sugar mod        is  "\%" ;
sugar not        is  "\!" ;

---- TODO: MOC
--sugar colon      is  "\:" ;
--sugar osbra      is  "\[" ;
--sugar csbra      is  "\]" ;
--sugar id         is  "id" ;
--sugar class      is  "@class" ;
--sugar end        is  "@end" ;
--sugar self       is "self" ;
--sugar bool       is  "BOOL" ;
--sugar super      is "super" ;
--sugar yes        is "YES" ;
--sugar no         is "NO" ;

term integer     is  "[0-9]+" ;
term character   is  "\'[^\']\'" ;
term string      is  "\"[^\"]*\"" ;
term ident       is  "[a-z][_0-9A-Za-z]*" ;
---- TODO: MOC
--term class_ident is  "[A-Z][_0-9A-Za-z]*" ; -- class name
--term stringo     is  "@\"[^\"]*\"" ; -- MOC string


PROGRAM -> #init ENTITIES #gen ;
global
    IMachine machine;
    ST st;

#init {
    machine = PROGRAM^source.getMachine();
    ENTITIES^machine = machine;

    st = new ST();
    ENTITIES^st = st;
}

#gen {
    -- debug
    if (PROGRAM^source.getVerbosity() >= 1) {
        write("### final symbols table ###\n");
        write(st);
        write("###########################\n");
    }

    -- write in a file
    machine.writeCode(PROGRAM^source.getFileName(), ENTITIES^code.getAsm());
}

ENTITIES ->#gen ;
#gen {
    ENTITIES^code = new Code("");
}

ENTITIES -> asm opar string cpar ENTITIES #gen ;
#gen {
    Code entCode = ENTITIES^machine.includeAsm(string^txt);
    entCode.appendAsm(ENTITIES1^code.getAsm());
    ENTITIES^code = entCode;
}

ENTITIES -> FUNCTION ENTITIES #gen ;
#gen {
    Code entCode = new Code(FUNCTION^code.getAsm());
    entCode.appendAsm(ENTITIES1^code.getAsm());
    ENTITIES^code = entCode;
}


-- functions
FUNCTION -> TYPE ident opar #trans FUNC_PARAMETERS cpar #st BLOC #gen ;
global LTYPES param_types;

#trans {
    -- symbols table for parameters
    ST st = new ST(FUNCTION^st);
    FUNC_PARAMETERS^st = st;
    BLOC^st = st;

    -- variable locator
    BLOC^vlocator = FUNCTION^machine.getVariableLocator();

    -- management of parameters
    param_types = new LTYPES();
    FUNC_PARAMETERS^types = param_types;
    FUNC_PARAMETERS^locator = FUNCTION^machine.getParametersLocator();
}

#st {
    INFO i = FUNCTION^st.localSearch(ident^txt);

    if (i != null) {
        error(VAR_exists, ident^txt);
    }
    else {
        TFUNCTION fun = new TFUNCTION(ident^txt, TYPE^type, param_types);
        FUNCTION^st.insert(ident^txt, new INFOFUN(fun));
        FUNCTION^st.setCurrentFunction(fun);
    }
}

#gen {
    FUNCTION^code = FUNCTION^machine.genFunction(FUNCTION^st.getCurrentFunction(), BLOC^code);
}

-- functions parameters
FUNC_PARAMETERS -> ;

FUNC_PARAMETERS -> FUNC_PARAMETER #trans FUNC_PARAMETERSX ;
#trans {
    STRING param_name = FUNC_PARAMETER^name;
    TTYPE param_type = FUNC_PARAMETER^type;

    FUNC_PARAMETERS^types.add(param_type);
    FUNC_PARAMETERSX^types = FUNC_PARAMETERS^types;

    -- useless, there is no other arguments for now
    INFO i = FUNC_PARAMETERS^st.localSearch(param_name);

    if (i != null) {
        error(PARAM_exists, param_name);
    }
    else {
        Location loc = FUNC_PARAMETERS^locator.generate(param_type);
        INFOVAR info = new INFOVAR(param_type, loc);
        FUNC_PARAMETERS^st.insert(param_name, info);
    }
}

FUNC_PARAMETERSX -> ;
FUNC_PARAMETERSX -> comma FUNC_PARAMETER #trans FUNC_PARAMETERSX ;
#trans {
    STRING param_name = FUNC_PARAMETER^name;
    TTYPE param_type = FUNC_PARAMETER^type;

    FUNC_PARAMETERSX^types.add(param_type);
    FUNC_PARAMETERSX1^types = FUNC_PARAMETERSX^types;

    INFO i = FUNC_PARAMETERSX^st.localSearch(param_name);

    if (i != null) {
        error(PARAM_exists, param_name);
    }
    else {
        Location loc = FUNC_PARAMETERSX^locator.generate(param_type);
        INFOVAR info = new INFOVAR(param_type, loc);
        FUNC_PARAMETERSX^st.insert(param_name, info);
    }
}

FUNC_PARAMETER -> TYPE ident #type ;
#type {
    FUNC_PARAMETER^type = TYPE^type;
    FUNC_PARAMETER^name = ident^txt;
}

-- base types and pointers
TYPE -> STYPE #trans REFS #type ;
#trans {
    REFS^htype = STYPE^type;
}

#type {
    TYPE^type = REFS^type;
}

REFS -> #type ;
#type {
    REFS^type = REFS^htype;
}

REFS -> mult #trans REFS #type ;
#trans {
    REFS1^htype = new TPOINTER(REFS^htype, REFS^machine.getPointerSize());
}

#type {
    REFS^type = REFS1^type;
}

-- base types
STYPE -> void #type ;
#type {
    STYPE^type = new TVOID();
}

STYPE -> int #type ;
#type {
    STYPE^type = new TINTEGER(STYPE^machine.getIntSize());
}

STYPE -> char #type ;
#type {
    STYPE^type = new TCHAR(STYPE^machine.getCharSize());
}

STYPE -> bool #type ;
#type {
    STYPE^type = new TBOOL(STYPE^machine.getBoolSize());
}

-- method body and instructions blocks
BLOC -> ocbra #trans INSTS ccbra #gen ;
global ST st;

#trans {
    st = new ST(BLOC^st);
    INSTS^st = st;
}

#gen {
    BLOC^code = BLOC^machine.genBloc(INSTS^code, BLOC^vlocator);

    -- debug
    if (BLOC^source.getVerbosity() >= 2) {
        write("### symbols table ###\n");
        write(st);
        write("#####################\n");
    }
}

-- instructions
INSTS ->#gen ;
#gen {
    INSTS^code = new Code("");
}

INSTS -> INST INSTS #gen ;
#gen {
    Code c = INST^code;
    c.appendAsm(INSTS1^code.getAsm());
    INSTS^code = c;
}

-- local variable declaration with or without initialization
INST -> TYPE ident #trans AFF semicolon #gen ;
#trans {
    AFF^htype = TYPE^type;
}

#gen {
    INFO i = INST^st.localSearch(ident^txt);

    if (i != null) {
        error(VAR_exists, ident^txt);
    }
    else {
        INFOVAR info = new INFOVAR(TYPE^type, INST^vlocator.generate(TYPE^type));
        INST^st.insert(ident^txt, info);
        INST^code = AFF^code;
    }
}

AFF -> affect A #gen ;
#gen {
    if (!AFF^htype.constructFrom(A^type)) {
        error(TYPES_incompatible, AFF^htype, A^type);
    }

    AFF^code =A^code;
}

AFF -> #gen ;
#gen {
    AFF^code = AFF^machine.genDecl(AFF^htype);
}

-- expression instruction (affectation and procedure call)
INST -> E semicolon #gen ;
#gen {
    INST^code = E^code;
}

-- instruction block
INST -> #trans BLOC #gen ;
#trans {
    BLOC^vlocator = INST^vlocator.getChild();
}

#gen {
    INST^code = BLOC^code;
}

-- conditional
INST -> if opar E cpar #type #trans BLOC ELSE #gen ;
#type {
    if (!E^type.testable()) {
        error(TYPE_not_bool, E^type);
    }
}

#trans {
    BLOC^vlocator = INST^vlocator.getChild();
    ELSE^vlocator = INST^vlocator.getChild();
}

#gen {
    INST^code =INST^machine.genConditional(E^code, BLOC^code, ELSE^code);
}

ELSE -> else BLOC #gen ;
#gen {
    ELSE^code = BLOC^code;
}

ELSE -> #gen ;
#gen {
    ELSE^code = new Code("");
}


-- function return
INST -> return E semicolon #gen ;
#gen {
    TTYPE return_type = INST^st.getCurrentFunction().getReturnType();
    if (!return_type.constructFrom(E^type)) {
        error(TYPES_incompatible, return_type, E^type);
    }

    INST^code = INST^machine.genReturn(E^code, INST^st.getCurrentFunction());
}

-- inline asm
INST -> asm opar string cpar #gen ;
#gen {
    INST^code = new Code(string^txt);
}

-- expressions
-----------------------------------------------------------------------
-- E = expression (including affectation)
-- A = expression figuring in an affectation
-- R = expression figuring in a relational expression
-- T = expression figuring in an additive expression (TERME)
-- F = expression figuring in a multiplicative expression (FACTOR)
-----------------------------------------------------------------------

-- affectation
E -> A #trans EX #gen ;
#trans {
    EX^htype = A^type;
    EX^hcode = A^code;
}

#gen {
    E^type = EX^type;
    E^code = EX^code;
}

EX -> affect A #gen ;
#gen {
    if (!EX^htype.constructFrom(A^type)) {
        error(TYPES_incompatible, EX^htype, A^type);
    }

    EX^type = A^type;
    EX^code = EX^machine.genAffectation(EX^hcode,A^code,A^type);
}

EX -> #gen ;
#gen {
    EX^type = EX^htype;
    EX^code = EX^hcode;
}

-- relation
A -> R #trans AX #gen ;
#trans {
    AX^htype = R^type;
    AX^hcode = R^code;

}

#gen {
    A^type = AX^type;
    A^code = AX^code;
}

AX -> OPREL R #gen ;
#gen {
    if (!AX^htype.comparableWith(R^type, OPREL^name)) {
        error(TYPES_incomparable, AX^htype, R^type, OPREL^name);
    }

    AX^type = new TBOOL(AX^machine.getBoolSize());
    AX^code = AX^machine.genBinary(AX^hcode, R^code, OPREL^name);
}

AX -> #gen ;
#gen {
    AX^type = AX^htype;
    AX^code = AX^hcode;
}

-- relation operators
OPREL -> inf #name ;
#name { OPREL^name = "<"; }

OPREL -> sup #name ;
#name { OPREL^name = ">"; }

OPREL -> infeq #name ;
#name { OPREL^name = "<="; }

OPREL -> supeq #name ;
#name { OPREL^name = ">="; }

OPREL -> eq #name ;
#name { OPREL^name = "=="; }

OPREL -> neq #name ;
#name { OPREL^name = "!="; }

-- additions
R -> T #trans RX #gen ;
#trans {
    RX^htype = T^type;
    RX^hcode = T^code;
}

#gen {
    R^type = RX^type;
    R^code = RX^code;
}

RX -> OPADD T #trans RX #gen ;
#trans {
    if (!RX^htype.binaryUsable(T^type, OPADD^name)) {
        error(TYPES_binary_unusable, RX^htype, T^type, OPADD^name);
    }

    RX1^htype = RX^htype;
    RX1^hcode = RX^machine.genBinary(RX^hcode, T^code, OPADD^name);
}

#gen {
    RX^type = RX1^type;
    RX^code = RX1^code;
}

RX -> #gen ;
#gen {
    RX^type = RX^htype;
    RX^code = RX^hcode;
}

-- addition operators
OPADD -> plus #name ;
#name { OPADD^name = "+"; }

OPADD -> minus #name ;
#name { OPADD^name = "-"; }

OPADD -> or #name ;
#name { OPADD^name = "||"; }

-- multiplications
T -> F #trans TX #gen ;
#trans {
    TX^htype = F^type;
    TX^hcode = F^code;
}

#gen {
    T^type = TX^type;
    T^code = TX^code;
}

TX -> OPMUL F #trans TX #gen ;
#trans {
    if (!TX^htype.binaryUsable(F^type, OPMUL^name)) {
        error(TYPES_binary_unusable, TX^htype, F^type, OPMUL^name);
    }

    TX1^htype = TX^htype;
    TX1^hcode = TX^machine.genBinary(TX^hcode, F^code, OPMUL^name);
}

#gen {
    TX^type = TX1^type;
    TX^code = TX1^code;
}

TX -> #gen ;
#gen {
    TX^type = TX^htype;
    TX^code = TX^hcode;
}

-- multiplication operators
OPMUL -> mult #name ;
#name { OPMUL^name = "*"; }

OPMUL -> div #name ;
#name { OPMUL^name = "/"; }

OPMUL -> mod #name ;
#name { OPMUL^name = "%"; }

OPMUL -> and #name ;
#name { OPMUL^name = "&&"; }

-- base expressions
F -> integer #gen ;
#gen {
    F^type = new TINTEGER(F^machine.getIntSize());
    F^code = F^machine.genInt(integer^txt);
}

F -> string #gen ;
#gen {
    F^type = new TPOINTER(new TCHAR(F^machine.getCharSize()), F^machine.getPointerSize());
    F^code = F^machine.genString(string^txt);
}

F -> character #gen ;
#gen {
    F^type = new TCHAR(F^machine.getCharSize());
    F^code = F^machine.genChar(character^txt);
}

F -> null #gen ;
#gen {
    F^type = new TNULL();
    F^code = F^machine.genNull();
}

F -> true #gen ;
#gen {
    F^type = new TBOOL(F^machine.getBoolSize());
    F^code = F^machine.genBool(1);
}

F -> false #gen ;
#gen {
    F^type = new TBOOL(F^machine.getBoolSize());
    F^code = F^machine.genBool(0);
}

F -> OPUN F #gen ;
#gen {
    if (!F1^type.unaryUsable(OPUN^name)) {
        error(TYPE_unary_unusable, F1^type, OPUN^name);
    }

    F^type = F1^type;
    F^code = F^machine.genUnary(F1^code, OPUN^name);
}

-- unary expressions
OPUN -> plus #name ;
#name { OPUN^name = "+"; }

OPUN -> minus #name ;
#name { OPUN^name = "-"; }

OPUN -> not #name ;
#name { OPUN^name = "!"; }

-- parenthesised expression
F -> opar E cpar #gen ;
#gen {
    F^type = E^type;
    F^code = E^code;
}

F -> opar TYPE cpar F #gen ;
#gen {
    if (F1^type.equals(TYPE^type)) {
        warning(TYPE_cast_useless, TYPE^type.toString(), TYPE^type.toString());
    }
    elseif (!F1^type.isCastableTo(TYPE^type)) {
        error(TYPE_uncastable, F1^type, TYPE^type);
    }

    F^type = TYPE^type;
    F^code = F^machine.genCast(TYPE^type, F1^code);
}

-- subprogram call
F -> ident opar #hgen ARGS cpar #gen ;
global LTYPES args_types;

#hgen {
    args_types = new LTYPES();
    ARGS^types = args_types;

    -- search for the function in the symbols table
    INFO i = F^st.globalSearch(ident^txt);

    if (i == null) {
        error(FUN_undefined, ident^txt);
    }
    else {
        match (i) {
            case INFOFUN {
                INFOFUN info = i;
                ARGS^function = info.getType();
                F^type = info.getType().getReturnType();
            }
            default {
                error(INFO_not_fun, ident^txt);
            }
        }
    }
}

#gen {
    F^code = F^machine.genCall(ident^txt, ARGS^code);
}

F -> ident #gen ;
#gen {
    INFO i = F^st.globalSearch(ident^txt);

    if (i == null) {
        error(VAR_undefined, ident^txt);
    }
    else {
        match (i) {
            case INFOVAR {
                INFOVAR info = i;
                F^type = info.getType();

                F^code = F^machine.genVariable(info);
            }
            default {
                error(INFO_not_var, ident^txt);
            }
        }
    }
}

-- pointed-to memory access
F -> mult F #gen ;
#gen {
    match (F1^type) {
        case TPOINTER {
            TPOINTER p = F1^type;
            F^type = p.getType();
            F^code = F^machine.genAcces(F1^code, p.getType());
        }
        default {
            error(TYPE_not_pointer, F1^type);
        }
    }
}

-- subprogram call arguments
ARGS -> #gen ;
#gen {
    if(ARGS^types.size() < ARGS^function.getParameterTypes().size()) {
        error(ARGS_too_few_arguments, ARGS^function.getName());
    }

    ARGS^code = new Code("");
}

ARGS -> E #trans ARGSX #gen;
#trans {
    ARGS^types.add(E^type);
    ARGSX^types = ARGS^types;
    ARGSX^hcode = E^code;

    if(ARGS^types.size() > ARGS^function.getParameterTypes().size()) {
        error(ARGS_too_many_arguments, ARGS^function.getName());
    }
    else {
        TTYPE needed_type = ARGS^function.getParameterTypes().get(ARGS^types.size() - 1);
        if (!needed_type.constructFrom(E^type)) {
            error(TYPES_incompatible, needed_type, E^type);
        }
    }
}

#gen {
    ARGS^code = ARGSX^code;
}

ARGSX -> #gen ;
#gen {
    if(ARGSX^types.size() < ARGSX^function.getParameterTypes().size()) {
        error(ARGS_too_few_arguments, ARGSX^function.getName());
    }
    ARGSX^code = ARGSX^hcode;
}

ARGSX -> comma E #trans ARGSX #gen ;
#trans {
    ARGSX^types.add(E^type);
    ARGSX1^types = ARGSX^types;

    if(ARGSX^types.size() > ARGSX^function.getParameterTypes().size()) {
        error(ARGS_too_many_arguments, ARGSX^function.getName());
    }
    else {
        TTYPE needed_type = ARGSX^function.getParameterTypes().get(ARGSX^types.size() - 1);
        if (!needed_type.constructFrom(E^type)) {
            error(TYPES_incompatible, needed_type, E^type);
        }
    }

    Code c = ARGSX^hcode;
    c.appendAsm(E^code.getAsm());
    ARGSX1^hcode = c;    
}

#gen {
    ARGSX^code = ARGSX1^code;
}

----============ MOC extension =================
--ENTITIES -> IMPLEMENTATION ENTITIES ;
---- class definition
--IMPLEMENTATION -> class class_ident SUPER ocbra ATTRIBUTES ccbra METHODS end ;
---- superclass
--SUPER -> ;
--SUPER -> colon class_ident ;
---- attributes
--ATTRIBUTES -> ;
--ATTRIBUTES -> TYPE ident semicolon ATTRIBUTES ;
---- methods
--METHODS -> ;
--METHODS -> METHOD METHODS ;
--METHOD -> QUAL PTYPE MFUNC_PARAMETERS BLOC ;
---- method or attribute qualifier: + = class, - = instance
--QUAL -> plus ;
--QUAL -> minus ;
---- type class
--STYPE-> class_ident ;
---- type BOOL
--STYPE-> bool ;
---- type "any"
--TYPE -> id ;
---- method return type between parentheses
--PTYPE-> opar TYPE cpar ;
---- method parameters
--MFUNC_PARAMETERS -> ;
--MFUNC_PARAMETERS -> MFUNC_PARAMETER MFUNC_PARAMETERS ;
---- selector without parameters
--MFUNC_PARAMETER -> ident ;
---- selector  + parameter type + parameter name
--MFUNC_PARAMETER -> ident colon PTYPE ident ;
--F -> nil ;
--F -> yes ;
--F -> no ;
---- MOC string (starts with @)
--F -> stringo ;
--F -> self ;
--F -> super ;
---- method call
--F -> osbra F MARGS csbra ;
---- for class method call
--F -> osbra class_ident MARGS csbra ;
---- method call arguments
--MARGS -> ;
--MARGS -> MARG MARGS ;
---- selector + arg
--MARG -> ident colon E ;
---- selector without arg
--MARG -> ident ;
