-------------------------
-- MC and MOC grammars --
-------------------------

option auto = true;
option version = 0.0.1;
option k = 3;

inh source : MOCSourceFile for
         PROGRAM, ENTITIES, STRUCT_FIELDS, GLOBAL_DECL, INST, BLOC, INSTS, ELSE,
         FUNC_PARAMETERS, FUNC_PARAMETER, FUNC_PARAMETERSX, ARGS, ARGSX, AFF,
         E, EX, A, AX, R, RX, T, TX, D, DX, F;
inh machine : IMachine for
         ENTITIES, STRUCT_FIELDS, GLOBAL_DECL, INST, BLOC, INSTS, ELSE,
         FUNC_PARAMETERS, FUNC_PARAMETER, FUNC_PARAMETERSX, ARGS, ARGSX, AFF,
         TYPE, STYPE, REFS,
         E, EX, A, AX, R, RX, T, TX, D, DX, F;
inh st : ST for
         ENTITIES, STRUCT_FIELDS, GLOBAL_DECL, INST, BLOC, INSTS, ELSE,
         FUNC_PARAMETERS, FUNC_PARAMETER, FUNC_PARAMETERSX, ARGS, ARGSX, AFF,
         TYPE, STYPE,
         E, EX, A, AX, R, RX, T, TX, D, DX, F;
inh types : LTYPES for FUNC_PARAMETERS, FUNC_PARAMETERSX, ARGS, ARGSX;
syn type : TTYPE for
         TYPE, STYPE, REFS, FUNC_PARAMETER,
         E, EX, A, AX, R, RX, T, TX, D, DX, F;
inh htype : TTYPE for GLOBAL_DECL, REFS, EX, AX, RX, TX, DX, AFF;
inh hident : STRING for GLOBAL_DECL;
inh hinfo : INFOVAR for AFF;
syn name : STRING for OPREL, OPADD, OPMUL, OPUN, FUNC_PARAMETER;
inh plocator : ParametersLocator for FUNC_PARAMETERS, FUNC_PARAMETERSX;
inh vlocator : VariableLocator for BLOC, INSTS, INST, ELSE;

syn code : Code for
         INST, BLOC, INSTS, ELSE,
         ARGS, ARGSX, AFF,
         E, EX, A, AX, R, RX, T, TX, D, DX, F;
syn globalCode : EntityCode for GLOBAL_DECL;
syn eCodes : EntityList for ENTITIES;
inh hcode : Code for
         EX, AX, RX, TX, DX, ARGSX;

syn exported : boolean for EXPORT;
inh hExported : boolean for GLOBAL_DECL;
inh hstruct : TSTRUCT for STRUCT_FIELDS;

-- to check subprogram call
inh function : TFUNCTION for ARGS, ARGSX;

space separator  is  "[\r\n\t ]+" ;
comment comm     is  "\/\/[^\n]*\n" ;
comment ml_comm  is  "\/\*([^\*]|(\*+[^\*\/]))*\*+\/" ;
sugar opar       is  "\(" ;
sugar cpar       is  "\)" ;
sugar ocbra      is  "\{" ;
sugar ccbra      is  "\}" ;
sugar comma      is  "," ;
sugar semicolon  is  "\;" ;
sugar affect     is  "=" ;
sugar export     is  "export" ;
sugar if         is  "if" ;
sugar else       is  "else" ;
sugar while      is  "while" ;
sugar t_for      is  "for" ;
sugar struct     is  "struct" ;
sugar void       is  "void" ;
sugar asm        is  "asm" ;
sugar int        is  "int" ;
sugar char       is  "char" ;
sugar bool       is  "bool" ;
sugar true       is  "true" ;
sugar false      is  "false" ;
sugar return     is  "return" ;
sugar null       is  "NULL" ;
sugar dot        is  "\." ;
sugar arrow      is  "\-\>" ;
sugar inf        is  "\<" ;
sugar infeq      is  "\<=" ;
sugar sup        is  "\>" ;
sugar supeq      is  "\>=" ;
sugar eq         is  "==" ;
sugar neq        is  "\!=" ;
sugar plus       is  "\+" ;
sugar minus      is  "\-" ;
sugar or         is  "\|\|" ;
sugar and        is  "\&\&" ;
sugar bit_or     is  "\|" ;
sugar bit_and    is  "\&" ;
sugar lshift     is  "\<\<" ;
sugar rshift     is  "\>\>" ;
sugar mult       is  "\*" ;
sugar div        is  "\/" ;
sugar mod        is  "\%" ;
sugar not        is  "\!" ;
sugar colon      is  "\:" ;
sugar osbra      is  "\[" ;
sugar csbra      is  "\]" ;

term integer     is  "(0x[0-9a-fA-F]+)|(0b[01]+)|([0-9]+)" ;
term character   is  "\'([^\']|\\[0nrt])\'" ;
term string      is  "\"[^\"]*\"" ;
term ident       is  "[a-z][_0-9A-Za-z]*" ;


PROGRAM -> #init ENTITIES #gen ;
global
    IMachine machine;
    ST st;

#init {
    machine = PROGRAM^source.getMachine();
    ENTITIES^machine = machine;

    st = new ST();
    ENTITIES^st = st;
}

#gen {
    -- debug
    if (PROGRAM^source.getVerbosity() >= 1) {
        write("### final symbols table ###\n");
        write(st);
        write("###########################\n");
    }

    -- write in a file
    machine.writeCode(PROGRAM^source.getFileName(), ENTITIES^eCodes);
}

ENTITIES -> #gen ;
#gen {
    ENTITIES^eCodes = new EntityList();
}

ENTITIES -> asm opar string cpar ENTITIES #gen ;
#gen {
    ENTITIES1^eCodes.prepend(
        ENTITIES^machine.genGlobalAsm(string^txt, ENTITIES^st)
    );
    ENTITIES^eCodes = ENTITIES1^eCodes;
}

-- structure declaration
ENTITIES -> struct ident ocbra #trans STRUCT_FIELDS ccbra semicolon #st ENTITIES #gen ;
global TSTRUCT struct;

#trans {
    -- check if the variable already exists
    INFO i = ENTITIES^st.localSearch(ident^txt);

    if (i != null) {
        error(VAR_exists, ident^txt);
    }
    else {
        struct = new TSTRUCT();
        STRUCT_FIELDS^hstruct = struct;
    }
}

#st {
    ENTITIES^st.insert(ident^txt, new INFOSTRUCT(struct));
}

#gen {
    ENTITIES^eCodes = ENTITIES1^eCodes;
}

STRUCT_FIELDS -> ;

STRUCT_FIELDS -> TYPE ident semicolon #st STRUCT_FIELDS ;
#st {
    if(STRUCT_FIELDS^hstruct.hasField(ident^txt)) {
        error(FIELD_exists, ident^txt);
    }

    STRUCT_FIELDS^hstruct.addField(ident^txt, TYPE^type);
}

-- global declaration (variable, function)
ENTITIES -> EXPORT TYPE ident #trans GLOBAL_DECL ENTITIES #gen ;
#trans {
    -- check if the variable already exists
    INFO i = ENTITIES^st.localSearch(ident^txt);

    if (i != null) {
        error(VAR_exists, ident^txt);
    }
    else {
        GLOBAL_DECL^htype = TYPE^type;
        GLOBAL_DECL^hident = ident^txt;
        GLOBAL_DECL^hExported = EXPORT^exported;
    }
}

#gen {
    ENTITIES1^eCodes.prepend(GLOBAL_DECL^globalCode);
    ENTITIES^eCodes = ENTITIES1^eCodes;
}

EXPORT -> #gen ;
#gen {
    EXPORT^exported = false;
}

EXPORT -> export #gen ;
#gen {
    EXPORT^exported = true;
}

-- global vars
GLOBAL_DECL -> semicolon #gen ;
#gen {
    INFOVAR info = new INFOVAR(GLOBAL_DECL^htype, GLOBAL_DECL^machine.genGlobalLocation());
    GLOBAL_DECL^st.insert(GLOBAL_DECL^hident, info);
    GLOBAL_DECL^globalCode = GLOBAL_DECL^machine.genDeclGlobal(info);
}

-- functions
GLOBAL_DECL -> opar #trans FUNC_PARAMETERS cpar #st BLOC #gen ;
global LTYPES param_types;
    TFUNCTION fun;

#trans {
    -- symbols table for parameters
    ST st = new ST(GLOBAL_DECL^st);
    FUNC_PARAMETERS^st = st;
    BLOC^st = st;

    -- variable locator
    BLOC^vlocator = GLOBAL_DECL^machine.getVariableLocator();

    -- management of parameters
    param_types = new LTYPES();
    FUNC_PARAMETERS^types = param_types;
    FUNC_PARAMETERS^plocator = GLOBAL_DECL^machine.getParametersLocator();
}

#st {
    fun = new TFUNCTION(GLOBAL_DECL^hident, GLOBAL_DECL^htype, param_types);
    GLOBAL_DECL^st.insert(GLOBAL_DECL^hident, new INFOFUN(fun));
    GLOBAL_DECL^st.setCurrentFunction(fun);
}

#gen {
    GLOBAL_DECL^globalCode = GLOBAL_DECL^machine.genFunction(
        fun, BLOC^code, GLOBAL_DECL^hExported
    );
    GLOBAL_DECL^st.setCurrentFunction(null);
}

-- functions parameters
FUNC_PARAMETERS -> ;

FUNC_PARAMETERS -> FUNC_PARAMETER #trans FUNC_PARAMETERSX ;
#trans {
    STRING param_name = FUNC_PARAMETER^name;
    TTYPE param_type = FUNC_PARAMETER^type;

    FUNC_PARAMETERS^types.add(param_type);
    FUNC_PARAMETERSX^types = FUNC_PARAMETERS^types;

    -- useless, there is no other arguments for now
    INFO i = FUNC_PARAMETERS^st.localSearch(param_name);

    if (i != null) {
        error(PARAM_exists, param_name);
    }
    else {
        Location loc = FUNC_PARAMETERS^plocator.generate(param_type);
        INFOVAR info = new INFOVAR(param_type, loc);
        FUNC_PARAMETERS^st.insert(param_name, info);
    }
}

FUNC_PARAMETERSX -> ;
FUNC_PARAMETERSX -> comma FUNC_PARAMETER #trans FUNC_PARAMETERSX ;
#trans {
    STRING param_name = FUNC_PARAMETER^name;
    TTYPE param_type = FUNC_PARAMETER^type;

    FUNC_PARAMETERSX^types.add(param_type);
    FUNC_PARAMETERSX1^types = FUNC_PARAMETERSX^types;

    -- check if the parameter already exists
    INFO i = FUNC_PARAMETERSX^st.localSearch(param_name);

    if (i != null) {
        error(PARAM_exists, param_name);
    }
    else {
        Location loc = FUNC_PARAMETERSX^plocator.generate(param_type);
        INFOVAR info = new INFOVAR(param_type, loc);
        FUNC_PARAMETERSX^st.insert(param_name, info);
    }
}

FUNC_PARAMETER -> TYPE ident #type ;
#type {
    FUNC_PARAMETER^type = TYPE^type;
    FUNC_PARAMETER^name = ident^txt;
}

-- base types and pointers
TYPE -> STYPE #trans REFS #type ;
#trans {
    REFS^htype = STYPE^type;
}

#type {
    TYPE^type = REFS^type;
}

REFS -> #type ;
#type {
    REFS^type = REFS^htype;
}

REFS -> mult #trans REFS #type ;
#trans {
    -- type TPOINTER
    REFS1^htype = new TPOINTER(REFS^htype, REFS^machine.getPointerSize());
}

#type {
    REFS^type = REFS1^type;
}

-- arrays
REFS -> osbra integer csbra #trans REFS #type ;
#trans {
    REFS1^htype = new TARRAY(REFS^htype, REFS^machine.getIntFromString(integer^txt));
}

#type {
    REFS^type = REFS1^type;
}

REFS -> osbra csbra #trans REFS #type ;
#trans {
    REFS1^htype = new TPOINTER(REFS^htype, REFS^machine.getPointerSize());
}

#type {
    REFS^type = REFS1^type;
}

-- base types
STYPE -> void #type ;
#type {
    STYPE^type = new TVOID();
}

STYPE -> int #type ;
#type {
    STYPE^type = new TINTEGER(STYPE^machine.getIntSize());
}

STYPE -> char #type ;
#type {
    STYPE^type = new TCHAR(STYPE^machine.getCharSize());
}

STYPE -> bool #type ;
#type {
    STYPE^type = new TBOOL(STYPE^machine.getBoolSize());
}

STYPE -> struct ident #type ;
#type {
    INFO i = STYPE^st.globalSearch(ident^txt);

    if (i == null) {
        error(STRUCT_undefined, ident^txt);
    }
    else {
        match (i) {
            case INFOSTRUCT {
                INFOSTRUCT info = i;
                STYPE^type = info.getType();
            }
            default {
                error(STRUCT_undefined, ident^txt);
            }
        }
    }
}

-- instructions blocks
BLOC -> ocbra #trans INSTS ccbra #gen ;
global ST st;

#trans {
    st = new ST(BLOC^st);
    INSTS^st = st;
}

#gen {
    BLOC^code = BLOC^machine.genBlock(INSTS^code, BLOC^vlocator);

    -- debug
    if (BLOC^source.getVerbosity() >= 2) {
        write("### symbols table ###\n");
        write(st);
        write("#####################\n");
    }
}

-- instructions
INSTS -> #gen ;
#gen {
    INSTS^code = new Code("");
}

INSTS -> INST INSTS #gen ;
#gen {
    Code c = INST^code;
    c.appendAsm(INSTS1^code.getAsm());
    INSTS^code = c;
}

-- local variable declaration with or without initialization
INST -> TYPE ident #trans AFF semicolon #gen ;
#trans {
    AFF^htype = TYPE^type;

    -- check if the variable already exists
    INFO i = INST^st.localSearch(ident^txt);

    if (i != null) {
        error(VAR_exists, ident^txt);
    }
    else {
        INFOVAR info = new INFOVAR(TYPE^type, INST^vlocator.generate(TYPE^type));
        INST^st.insert(ident^txt, info);
        AFF^hinfo = info;
    }
}

#gen {
    INST^code = AFF^code;
}

AFF -> affect A #gen ;
#gen {
    if (!AFF^htype.constructFrom(A^type)) {
        error(TYPES_incompatible, AFF^htype, A^type);
    }

    AFF^code = AFF^machine.genDecl(AFF^hinfo, A^code, A^type);
}

AFF -> #gen ;
#gen {
    AFF^code = AFF^machine.genDecl(AFF^hinfo);
}

-- expression instruction (affectation and procedure call)
INST -> E semicolon #gen ;
#gen {
    INST^code = INST^machine.genInst(E^type, E^code);
}

-- instruction block
INST -> #trans BLOC #gen ;
#trans {
    BLOC^vlocator = INST^vlocator.getChild();
}

#gen {
    INST^code = BLOC^code;
}

-- conditional
INST -> if opar E cpar #trans BLOC ELSE #gen ;
#trans {
    if (!E^type.testable()) {
        error(TYPE_not_bool, E^type);
    }

    BLOC^vlocator = INST^vlocator.getChild();
    ELSE^vlocator = INST^vlocator.getChild();
}

#gen {
    INST^code = INST^machine.genConditional(E^code, BLOC^code, ELSE^code);
}

ELSE -> else BLOC #gen ;
#gen {
    ELSE^code = BLOC^code;
}

ELSE -> #gen ;
#gen {
    ELSE^code = new Code("");
}

-- while loop
INST -> while opar E cpar #trans BLOC #gen ;
#trans {
    if (!E^type.testable()) {
        error(TYPE_not_bool, E^type);
    }

    BLOC^vlocator = INST^vlocator.getChild();
}

#gen {
    INST^code = INST^machine.genWhileLoop(E^code, BLOC^code);
}

-- for loop
INST -> t_for opar E semicolon A semicolon E cpar #trans BLOC #gen ;
#trans {
    if (!A^type.testable()) {
        error(TYPE_not_bool, A^type);
    }
    if (!instanceof(E^type, TVOID)) {
        error(TYPE_not_assignment, E^type);
    }
    if (!instanceof(E1^type, TVOID)) {
        error(TYPE_not_assignment, E1^type);
    }

    BLOC^vlocator = INST^vlocator.getChild();
}

#gen {
    INST^code = INST^machine.genForLoop(E^code, A^code, E1^code, BLOC^code);
}

-- function return
INST -> return E semicolon #gen ;
#gen {
    TTYPE returnType;

    returnType = INST^st.getCurrentFunction().getReturnType();

    if (!returnType.constructFrom(E^type)) {
        error(TYPES_incompatible, returnType, E^type);
    }

    INST^code = INST^machine.genFunctionReturn(E^code, INST^st.getCurrentFunction());
}

-- inline asm
INST -> asm opar string cpar semicolon #gen ;
#gen {
    INST^code = INST^machine.genAsm(string^txt, INST^st);
}

-- expressions
-----------------------------------------------------------------------
-- E = expression (including affectation)
-- A = expression figuring in an affectation
-- R = expression figuring in a relational expression
-- T = expression figuring in an additive expression (TERME)
-- D = dotted expression
-- F = expression figuring in a multiplicative expression (FACTOR)
-----------------------------------------------------------------------

-- affectation
E -> A #trans EX #gen ;
#trans {
    EX^htype = A^type;
    EX^hcode = A^code;
}

#gen {
    E^type = EX^type;
    E^code = EX^code;
}

EX -> affect A #gen ;
#gen {
    if (!EX^htype.constructFrom(A^type)) {
        error(TYPES_incompatible, EX^htype, A^type);
    }
    elseif (!EX^hcode.getIsAddress() && EX^hcode.getLocation() == null) {
        error(AFF_impossible);
    }

    EX^type = new TVOID();
    EX^code = EX^machine.genAffectation(EX^hcode, A^code, A^type);
}

EX -> #gen ;
#gen {
    EX^type = EX^htype;
    EX^code = EX^hcode;
}

-- relation
A -> R #trans AX #gen ;
#trans {
    AX^htype = R^type;
    AX^hcode = R^code;

}

#gen {
    A^type = AX^type;
    A^code = AX^code;
}

AX -> OPREL R #gen ;
#gen {
    if (!AX^htype.comparableWith(R^type, OPREL^name)) {
        error(TYPES_incomparable, AX^htype, R^type, OPREL^name);
    }

    AX^type = new TBOOL(AX^machine.getBoolSize());
    AX^code = AX^machine.genBinary(AX^hcode, AX^htype, R^code, R^type, OPREL^name);
}

AX -> #gen ;
#gen {
    AX^type = AX^htype;
    AX^code = AX^hcode;
}

-- relation operators
OPREL -> inf #name ;
#name { OPREL^name = "<"; }

OPREL -> sup #name ;
#name { OPREL^name = ">"; }

OPREL -> infeq #name ;
#name { OPREL^name = "<="; }

OPREL -> supeq #name ;
#name { OPREL^name = ">="; }

OPREL -> eq #name ;
#name { OPREL^name = "=="; }

OPREL -> neq #name ;
#name { OPREL^name = "!="; }

-- additions
R -> T #trans RX #gen ;
#trans {
    RX^htype = T^type;
    RX^hcode = T^code;
}

#gen {
    R^type = RX^type;
    R^code = RX^code;
}

RX -> OPADD T #trans RX #gen ;
#trans {
    if (!RX^htype.binaryUsable(T^type, OPADD^name)) {
        error(TYPES_binary_unusable, RX^htype, T^type, OPADD^name);
    }

    RX1^htype = RX^htype;
    RX1^hcode = RX^machine.genBinary(RX^hcode, RX^htype, T^code, T^type, OPADD^name);
}

#gen {
    RX^type = RX1^type;
    RX^code = RX1^code;
}

RX -> #gen ;
#gen {
    RX^type = RX^htype;
    RX^code = RX^hcode;
}

-- addition operators
OPADD -> plus #name ;
#name { OPADD^name = "+"; }

OPADD -> minus #name ;
#name { OPADD^name = "-"; }

OPADD -> or #name ;
#name { OPADD^name = "||"; }

-- multiplications
T -> D #trans TX #gen ;
#trans {
    TX^htype = D^type;
    TX^hcode = D^code;
}

#gen {
    T^type = TX^type;
    T^code = TX^code;
}

TX -> OPMUL D #trans TX #gen ;
#trans {
    if (!TX^htype.binaryUsable(D^type, OPMUL^name)) {
        error(TYPES_binary_unusable, TX^htype, D^type, OPMUL^name);
    }

    TX1^htype = TX^htype;
    TX1^hcode = TX^machine.genBinary(TX^hcode, TX^htype, D^code, D^type, OPMUL^name);
}

#gen {
    TX^type = TX1^type;
    TX^code = TX1^code;
}

TX -> #gen ;
#gen {
    TX^type = TX^htype;
    TX^code = TX^hcode;
}

-- multiplication operators
OPMUL -> mult #name ;
#name { OPMUL^name = "*"; }

OPMUL -> div #name ;
#name { OPMUL^name = "/"; }

OPMUL -> mod #name ;
#name { OPMUL^name = "%"; }

OPMUL -> and #name ;
#name { OPMUL^name = "&&"; }

OPMUL -> bit_and #name ;
#name { OPMUL^name = "&"; }

OPMUL -> bit_or #name ;
#name { OPMUL^name = "|"; }

OPMUL -> lshift #name ;
#name { OPMUL^name = "<<"; }

OPMUL -> rshift #name ;
#name { OPMUL^name = ">>"; }

-- dotted expression
D -> F #trans DX #gen ;
#trans {
    DX^htype = F^type;
    DX^hcode = F^code;
}

#gen {
    D^type = DX^type;
    D^code = DX^code;
}

DX -> dot ident #trans DX #gen ;
#trans {
    match (DX^htype) {
        case TSTRUCT {
            TSTRUCT type = DX^htype;

            if(!type.hasField(ident^txt)) {
                error(STRUCT_no_field, type, ident^txt);
            }
            else {
                FIELD field = type.getField(ident^txt);
                DX1^htype = field.getType();
                DX1^hcode = DX^machine.genFieldAccess(type, field, DX^hcode);
            }
        }
        default {
            error(TYPE_not_struct, DX^htype);
        }
    }
}

#gen {
    DX^type = DX1^type;
    DX^code = DX1^code;
}

DX -> arrow ident #trans DX #gen ;
#trans {
    match (DX^htype) {
        case TPOINTER {
            TPOINTER pointerType = DX^htype;
            TTYPE pointedType = pointerType.getType();

            match (pointedType) {
                case TSTRUCT {
                        TSTRUCT type = pointedType;

                        if(!type.hasField(ident^txt)) {
                            error(STRUCT_no_field, type, ident^txt);
                        }
                        else {
                            FIELD field = type.getField(ident^txt);
                            DX1^htype = field.getType();
                            DX1^hcode = DX^machine.genPointerFieldAccess(type, field, DX^hcode);
                        }
                }
                default {
                    error(TYPE_not_struct_pointer, DX^htype);
                }
            }
        }
        default {
            error(TYPE_not_struct_pointer, DX^htype);
        }
    }
}

#gen {
    DX^type = DX1^type;
    DX^code = DX1^code;
}

DX -> #gen ;
#gen {
    DX^type = DX^htype;
    DX^code = DX^hcode;
}

-- base expressions
F -> integer #gen ;
#gen {
    F^type = new TINTEGER(F^machine.getIntSize());
    F^code = F^machine.genInt(integer^txt);
}

F -> string #gen ;
#gen {
    F^type = new TPOINTER(new TCHAR(F^machine.getCharSize()), F^machine.getPointerSize());
    F^code = F^machine.genString(string^txt);
}

F -> character #gen ;
#gen {
    F^type = new TCHAR(F^machine.getCharSize());
    F^code = F^machine.genChar(character^txt);
}

F -> null #gen ;
#gen {
    F^type = new TNULL(F^machine.getPointerSize());
    F^code = F^machine.genNull();
}

F -> true #gen ;
#gen {
    F^type = new TBOOL(F^machine.getBoolSize());
    F^code = F^machine.genBool(1);
}

F -> false #gen ;
#gen {
    F^type = new TBOOL(F^machine.getBoolSize());
    F^code = F^machine.genBool(0);
}

F -> OPUN F #gen ;
#gen {
    if (!F1^type.unaryUsable(OPUN^name)) {
        error(TYPE_unary_unusable, F1^type, OPUN^name);
    }

    F^type = F1^type;
    F^code = F^machine.genUnary(F1^code, F1^type, OPUN^name);
}

-- unary expressions
OPUN -> plus #name ;
#name { OPUN^name = "+"; }

OPUN -> minus #name ;
#name { OPUN^name = "-"; }

OPUN -> not #name ;
#name { OPUN^name = "!"; }

-- parenthesised expression
F -> opar E cpar #gen ;
#gen {
    F^type = E^type;
    F^code = E^code;
}

F -> opar TYPE cpar F #gen ;
#gen {
    if (F1^type.equals(TYPE^type)) {
        warning(TYPE_cast_useless, TYPE^type.toString(), TYPE^type.toString());
    }
    elseif (!F1^type.isCastableTo(TYPE^type)) {
        error(TYPE_uncastable, F1^type, TYPE^type);
    }

    F^type = TYPE^type;
    F^code = F^machine.genCast(TYPE^type, F1^type, F1^code);
}

-- subprogram call
F -> ident opar #hgen ARGS cpar #gen ;
global LTYPES args_types; TFUNCTION fun;

#hgen {
    args_types = new LTYPES();
    ARGS^types = args_types;

    -- search for the function in the symbols table
    INFO i = F^st.globalSearch(ident^txt);

    if (i == null) {
        error(FUN_undefined, ident^txt);
    }
    else {
        match (i) {
            case INFOFUN {
                INFOFUN info = i;
                fun = info.getType();
                ARGS^function = fun;
                F^type = info.getType().getReturnType();
            }
            default {
                error(INFO_not_fun, ident^txt);
            }
        }
    }
}

#gen {
    F^code = F^machine.genFunctionCall(
        F^st.getCurrentFunction().getName(),
        fun, ARGS^code
    );
}

F -> ident #gen ;
#gen {
    -- search for ident in the symbols table
    INFO i = F^st.globalSearch(ident^txt);

    if (i == null) {
        error(VAR_undefined, ident^txt);
    }
    else {
        match (i) {
            case INFOVAR {
                INFOVAR info = i;
                F^type = info.getType();
                F^code = F^machine.genVariable(info);
            }
            default {
                error(INFO_not_var, ident^txt);
            }
        }
    }
}

-- address
F -> bit_and ident #gen ;
#gen {
    -- search for ident in the symbols table
    INFO i = F^st.globalSearch(ident^txt);

    if (i == null) {
        error(VAR_undefined, ident^txt);
    }
    else {
        match (i) {
            case INFOVAR {
                INFOVAR info = i;
                F^type = new TPOINTER(info.getType(), F^machine.getPointerSize());
                F^code = F^machine.genAddress(info);
            }
            default {
                error(INFO_not_var, ident^txt);
            }
        }
    }
}

-- pointed-to memory access
F -> mult F #gen ;
#gen {
    match (F1^type) {
        case TPOINTER {
            TPOINTER p = F1^type;
            F^type = p.getType();
            F^code = F^machine.genAccess(F1^code, p.getType());
        }
        default {
            error(TYPE_not_pointer, F1^type);
        }
    }
}

-- array access
F -> ident osbra A csbra #gen ;
#gen {
    -- search for ident in the symbols table
    INFO i = F^st.globalSearch(ident^txt);

    if (i == null) {
        error(VAR_undefined, ident^txt);
    }
    else {
        match (i) {
            case INFOVAR {
                INFOVAR info = i;
                TTYPE varType = info.getType();

                match (A^type) {
                    case TINTEGER {
                        match (varType) {
                            case TARRAY {
                                TARRAY type = varType;
                                F^type = type.getElementsType();
                                F^code = F^machine.genStackArrayAccess(info, A^code);
                            }
                            case TPOINTER {
                                TPOINTER type = varType;
                                F^type = type.getType();
                                F^code = F^machine.genPointerArrayAccess(info, A^code);
                            }
                            default {
                                error(TYPE_not_array, varType);
                            }
                        }
                    }
                    default {
                        error(TYPE_not_integer, A^type);
                    }
                }
            }
            default {
                error(INFO_not_var, ident^txt);
            }
        }
    }
}

-- subprogram call arguments
ARGS -> #gen ;
#gen {
    -- check number of parameters
    if (ARGS^types.size() < ARGS^function.getParameterTypes().size()) {
        error(ARGS_too_few_arguments, ARGS^function.getName());
    }

    ARGS^code = new Code("");
}

ARGS -> E #trans ARGSX #gen;
#trans {
    ARGS^types.add(E^type);
    ARGSX^types = ARGS^types;
    ARGSX^hcode = ARGS^machine.genArg(E^code, E^type);

    -- check number of parameters
    if (ARGS^types.size() > ARGS^function.getParameterTypes().size()) {
        error(ARGS_too_many_arguments, ARGS^function.getName());
    }
    else {
        TTYPE needed_type = ARGS^function.getParameterTypes().get(ARGS^types.size() - 1);
        if (!needed_type.constructFrom(E^type)) {
            error(TYPES_incompatible, needed_type, E^type);
        }
    }
}

#gen {
    ARGS^code = ARGSX^code;
}

ARGSX -> #gen ;
#gen {
    if (ARGSX^types.size() < ARGSX^function.getParameterTypes().size()) {
        error(ARGS_too_few_arguments, ARGSX^function.getName());
    }

    ARGSX^code = ARGSX^hcode;
}

ARGSX -> comma E #trans ARGSX #gen ;
#trans {
    ARGSX^types.add(E^type);
    ARGSX1^types = ARGSX^types;

    -- check number of parameters
    if (ARGSX^types.size() > ARGSX^function.getParameterTypes().size()) {
        error(ARGS_too_many_arguments, ARGSX^function.getName());
    }
    else {
        TTYPE needed_type = ARGSX^function.getParameterTypes().get(ARGSX^types.size() - 1);
        if (!needed_type.constructFrom(E^type)) {
            error(TYPES_incompatible, needed_type, E^type);
        }
    }

    Code c = ARGSX^machine.genArg(E^code, E^type);
    c.appendAsm(ARGSX^hcode.getAsm());
    ARGSX1^hcode = c;
}

#gen {
    ARGSX^code = ARGSX1^code;
}
